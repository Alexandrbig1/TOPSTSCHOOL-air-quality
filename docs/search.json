[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome SCHOOL Module 2: Air Quality",
    "section": "",
    "text": "Welcome to the second module of the SCHOOL curriculum!\nThe Science Core Heuristics for Open Science Outcomes in Learning (SCHOOL) is part of the NASA Transform to Open Science (TOPS) Training (TOPST) initiative, designed to teach the data science lifecycle using data from the NASA Earth Sciences division and to foster an inclusive culture of open science. You can learn more about the SCHOOL Project and other modules on the SCHOOL Project home page.\nThe second SCHOOL module on the theme of “Air Quality and Health” explores how particulates in the air impact humans and how they are affected by the changes in air quality. The module consists of three use cases that cover examples of …… and …. such as …..\nEach use case uses a unique dataset to walk users through lessons in accessing and analyzing data, and further adapting the code to perform their analyses including data cleaning, processing to subset to an area of interest, and creating visualizations to share what they have learned with their communities.\nThis module is tailored to instruct undergraduate students and early-career researchers with some coding language exposure about the data science life cycle, illustrating how Open Science principles can be effectively applied to earth sciences, particularly in the context of water.\nThe SCHOOL Modules do not intend to teach all-encompassing earth science lessons nor provide learners with total coding expertise. Instead, the SCHOOL Project aims to provide users with the skills to adapt the SCHOOL lessons to the users’ own Open Science workflow. To learn more about Open Science, explore NASA’s TOPS Open Science 101 Curriculum. To explore other themes in the SCHOOL project, visit our Modules Page.\nModule 2: Air Quality datasets and use cases cover:\n\nEnabling Student-led Air Quality and Extreme Temperature Monitoring in New York: Examining the relationship between two environmental hazards – hazardous air quality and temperature – and socioeconomic characteristics of New York State (NYS) schools.\n\nLesson 1: Acquiring, Pre-Processing, and Visualizing Student-Monitored Data for New York City (NYC) Schools\n\nSocial Vulnerability Index (SVI) Social Determinants of Health: Exploring social determinants of health within the USA with the SVI.\n\nLesson 2: Exploring the Social Vulnerability Index (SVI) Social Determinants of Health\n\nEJScreen: Environmental Justice Screening and Mapping Tool: EJScreen is the Environmental justice mapping and screening tool that helps users understand the environmental and demographic characteristics of a specific area.\n\nLesson 3: Exploring EJScreen: Environmental Justice Screening and Mapping Tool\n\nGlobal Gridded Relative Deprivation Index Version 1 (GRDIv1), and the Global (GL) Annual PM2.5 Grids from MODIS, MISR and SeaWiFS Aerosol Optical Depth: Analyzing the global relationships between socioeconomic vulnerability and particulate matter concentrations over years.\n\nLesson 4: Global Gridded Relative Deprivation Index Version 1 (GRDIv1) and the Global Annual PM2.5 Grids\n\n\n\nStart Lesson 1\n\nThis course was made possible thanks to the work of our NASA Transform to Open Science (TOPS) team, our SCHOOL Open Science team, open science Subject Matter Experts (SMEs), and the SCHOOL Development team!"
  },
  {
    "objectID": "m201-student-led-monitoring-nyc.html",
    "href": "m201-student-led-monitoring-nyc.html",
    "title": "Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York",
    "section": "",
    "text": "In this lesson, you will use…."
  },
  {
    "objectID": "m201-student-led-monitoring-nyc.html#learning-objectives",
    "href": "m201-student-led-monitoring-nyc.html#learning-objectives",
    "title": "Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter completing this lesson, you should be able to:\n\nDetermine…"
  },
  {
    "objectID": "m201-student-led-monitoring-nyc.html#introduction",
    "href": "m201-student-led-monitoring-nyc.html#introduction",
    "title": "Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York",
    "section": "Introduction",
    "text": "Introduction\nThis project, “Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York,” led by Carolynne Hultquist and her team, aims to engage students in monitoring environmental hazards, specifically hazardous air quality and extreme temperature, outside and inside New York State schools. The focus is on New York City (NYC) schools serving low-income minority populations located in environmental justice communities characterized by high levels of hazard exposure. By incorporating mobile and static monitoring techniques, students contribute to data collection and analysis, integrating satellite data and sensor networks. This initiative not only provides valuable data on environmental conditions but also educates students on the principles of open science and the data science life cycle."
  },
  {
    "objectID": "m201-student-led-monitoring-nyc.html#data-collection-and-preparation",
    "href": "m201-student-led-monitoring-nyc.html#data-collection-and-preparation",
    "title": "Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York",
    "section": "Data Collection and Preparation",
    "text": "Data Collection and Preparation\n\nMobile and Static Monitoring\nEquip students with mobile sensors to collect air quality data. Compare this with data from static sensors placed in schools and remote sensing sources.\n\n\nSatellite Data Integration\nUtilize satellite data such as MODIS, OMI, MERRA-2, GOES, CHIRTS-daily, and SEDAC’s Air Quality Data to complement ground data.\n\n\nData Upload and Management\nStudents upload collected data to an online platform, ensuring proper documentation and metadata inclusion to maintain data quality and integrity."
  },
  {
    "objectID": "m201-student-led-monitoring-nyc.html#data-cleaning-and-preprocessing",
    "href": "m201-student-led-monitoring-nyc.html#data-cleaning-and-preprocessing",
    "title": "Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York",
    "section": "Data Cleaning and Preprocessing",
    "text": "Data Cleaning and Preprocessing\n\nData Validation\nCheck for inconsistencies or anomalies in the collected data. This includes cross-referencing mobile sensor data with static and satellite data to ensure accuracy.\n\n\nHandling Missing Data\nApply techniques such as interpolation or imputation to address missing data points, ensuring a complete dataset for analysis."
  },
  {
    "objectID": "m201-student-led-monitoring-nyc.html#data-analysis-and-visualization",
    "href": "m201-student-led-monitoring-nyc.html#data-analysis-and-visualization",
    "title": "Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York",
    "section": "Data Analysis and Visualization",
    "text": "Data Analysis and Visualization\n\nDescriptive Statistics\nCalculate basic statistics (mean, median, mode, standard deviation) to understand the distribution and central tendencies of the data.\n\n\nCorrelation Analysis\nExamine relationships between air quality, temperature, and socioeconomic characteristics of the schools.\n\n\nVisualization\nUse tools like ArcGIS Online for participatory mapping and visualizations to represent data spatially and temporally. Modeling and Interpretation\n\n\nPredictive Modeling\nDevelop models to predict air quality and temperature variations based on historical data and current trends. Impact Analysis: Assess the health impacts of hazardous air quality and extreme temperatures on school populations, with a focus on vulnerable groups. Reporting and Communication\n\n\nStory Development\nEngage with the Solutions Journalism Network to develop stories that highlight the project’s findings and advocate for environmental justice.\n\n\nPublications and Presentations\nCompile findings into reports, articles, and presentations for dissemination through academic channels and public forums."
  },
  {
    "objectID": "m201-student-led-monitoring-nyc.html#open-science-principles-and-data-sharing",
    "href": "m201-student-led-monitoring-nyc.html#open-science-principles-and-data-sharing",
    "title": "Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York",
    "section": "Open Science Principles and Data Sharing",
    "text": "Open Science Principles and Data Sharing\n\nTransparency\nEnsure all data processing steps, methodologies, and code are well-documented and accessible.\n\n\nReproducibility\nProvide clear instructions and datasets for others to replicate the study.\n\n\nData Sharing\nPublish datasets and findings in open-access repositories to promote further research and collaboration.\nCongratulations! …. Now you should be able to:\n\nTest test."
  },
  {
    "objectID": "m201-student-led-monitoring-nyc.html#lesson-2",
    "href": "m201-student-led-monitoring-nyc.html#lesson-2",
    "title": "Enabling Student-led Air Quality and Extreme Temperature Monitoring in New York",
    "section": "Lesson 2",
    "text": "Lesson 2\nIn this lesson, we explored ….\nLesson 2: EJSCREEN"
  },
  {
    "objectID": "m202-ejscreen.html",
    "href": "m202-ejscreen.html",
    "title": "EJSCREEN tool",
    "section": "",
    "text": "In this lesson, you will use…."
  },
  {
    "objectID": "m202-ejscreen.html#learning-objectives",
    "href": "m202-ejscreen.html#learning-objectives",
    "title": "EJSCREEN tool",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter completing this lesson, you should be able to:\n\nDetermine…"
  },
  {
    "objectID": "m202-ejscreen.html#introduction",
    "href": "m202-ejscreen.html#introduction",
    "title": "EJSCREEN tool",
    "section": "Introduction",
    "text": "Introduction\nIn recent years, researchers have explored the intersection between environmental factors and public health, particularly concerning diseases like COVID-19 and non-small cell lung cancer (NSCLC). Studies have highlighted the impact of air pollution on disease susceptibility and outcomes, emphasizing the need for rigorous analysis and understanding of these relationships. This overview focuses on several key studies that utilize data science principles to investigate how environmental justice, air pollution, and demographic factors intersect, providing insights that contribute to open science principles and the data science life cycle."
  },
  {
    "objectID": "m202-ejscreen.html#data-collection-and-integration",
    "href": "m202-ejscreen.html#data-collection-and-integration",
    "title": "EJSCREEN tool",
    "section": "Data Collection and Integration",
    "text": "Data Collection and Integration\nGather comprehensive datasets from reliable sources such as the US EPA’s EJSCREEN tool and other public health databases like John Hopkins and County Health Rankings. Integrate relevant environmental data (e.g., air pollutant concentrations, pollution source proximity) with health outcomes data (e.g., COVID-19 prevalence, NSCLC incidence). Ensure data compatibility and quality through data cleaning and validation procedures.\n\nExploratory Data Analysis (EDA)\nConduct initial exploratory analyses to understand the distribution and relationships within the data. Visualize data using plots and charts to identify patterns and correlations between environmental factors, demographic variables, and health outcomes. Perform statistical tests to assess associations and identify potential confounding factors.\n\n\nModel Development and Analysis\nApply statistical models (e.g., regression analyses, machine learning algorithms) to quantify the relationships between environmental exposures and health outcomes. Adjust for confounders such as demographic characteristics (e.g., age, race/ethnicity) and socioeconomic factors (e.g., income, education). Validate models using cross-validation techniques to ensure robustness and generalizability of findings.\n\n\nInterpretation and Communication of Results\nInterpret findings in the context of environmental justice principles, highlighting disparities and vulnerabilities observed in different populations. Discuss implications for public health policy and environmental regulations based on study outcomes. Communicate results transparently using accessible language and visual aids to engage stakeholders and the broader community."
  },
  {
    "objectID": "m202-ejscreen.html#the-data-science-life-cycle",
    "href": "m202-ejscreen.html#the-data-science-life-cycle",
    "title": "EJSCREEN tool",
    "section": "The Data Science Life Cycle",
    "text": "The Data Science Life Cycle\nThe data science life cycle guides the systematic approach to handling data from collection to interpretation:\n\nData Acquisition\nObtain relevant datasets from sources like EJSCREEN, County Health Rankings, and specific studies’ databases. ### Data Preparation Clean and preprocess data to ensure accuracy and consistency, handling missing values and outliers appropriately.\n\n\nExploratory Data Analysis\nExplore data distributions, correlations, and initial insights to guide further analysis.\n\n\nModeling\nDevelop statistical models to test hypotheses and predict outcomes, considering factors like pollution exposure and demographic variables.\n\n\nEvaluation\nAssess model performance and validity through metrics and cross-validation techniques.\n\n\nDeployment\nCommunicate findings through reports, presentatio\nCongratulations! …. Now you should be able to:\n\nTest test…"
  },
  {
    "objectID": "m202-ejscreen.html#lesson-2",
    "href": "m202-ejscreen.html#lesson-2",
    "title": "EJSCREEN tool",
    "section": "Lesson 2",
    "text": "Lesson 2\nIn this lesson, we explored ….\nLesson 2: EJSCREEN"
  },
  {
    "objectID": "m202-ejscreen.html#lesson-3",
    "href": "m202-ejscreen.html#lesson-3",
    "title": "EJSCREEN tool",
    "section": "Lesson 3",
    "text": "Lesson 3\nIn this lesson, we explored ….\nLesson 3"
  },
  {
    "objectID": "m202-svi-ejscreen.html",
    "href": "m202-svi-ejscreen.html",
    "title": "EJSCREEN tool",
    "section": "",
    "text": "In this lesson, you will use…."
  },
  {
    "objectID": "m202-svi-ejscreen.html#learning-objectives",
    "href": "m202-svi-ejscreen.html#learning-objectives",
    "title": "EJSCREEN tool",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter completing this lesson, you should be able to:\n\nDetermine…"
  },
  {
    "objectID": "m202-svi-ejscreen.html#introduction",
    "href": "m202-svi-ejscreen.html#introduction",
    "title": "EJSCREEN tool",
    "section": "Introduction",
    "text": "Introduction\nIn recent years, researchers have explored the intersection between environmental factors and public health, particularly concerning diseases like COVID-19 and non-small cell lung cancer (NSCLC). Studies have highlighted the impact of air pollution on disease susceptibility and outcomes, emphasizing the need for rigorous analysis and understanding of these relationships. This overview focuses on several key studies that utilize data science principles to investigate how environmental justice, air pollution, and demographic factors intersect, providing insights that contribute to open science principles and the data science life cycle."
  },
  {
    "objectID": "m202-svi-ejscreen.html#data-collection-and-integration",
    "href": "m202-svi-ejscreen.html#data-collection-and-integration",
    "title": "EJSCREEN tool",
    "section": "Data Collection and Integration",
    "text": "Data Collection and Integration\nGather comprehensive datasets from reliable sources such as the US EPA’s EJSCREEN tool and other public health databases like John Hopkins and County Health Rankings. Integrate relevant environmental data (e.g., air pollutant concentrations, pollution source proximity) with health outcomes data (e.g., COVID-19 prevalence, NSCLC incidence). Ensure data compatibility and quality through data cleaning and validation procedures.\n\nExploratory Data Analysis (EDA)\nConduct initial exploratory analyses to understand the distribution and relationships within the data. Visualize data using plots and charts to identify patterns and correlations between environmental factors, demographic variables, and health outcomes. Perform statistical tests to assess associations and identify potential confounding factors.\n\n\nModel Development and Analysis\nApply statistical models (e.g., regression analyses, machine learning algorithms) to quantify the relationships between environmental exposures and health outcomes. Adjust for confounders such as demographic characteristics (e.g., age, race/ethnicity) and socioeconomic factors (e.g., income, education). Validate models using cross-validation techniques to ensure robustness and generalizability of findings.\n\n\nInterpretation and Communication of Results\nInterpret findings in the context of environmental justice principles, highlighting disparities and vulnerabilities observed in different populations. Discuss implications for public health policy and environmental regulations based on study outcomes. Communicate results transparently using accessible language and visual aids to engage stakeholders and the broader community."
  },
  {
    "objectID": "m202-svi-ejscreen.html#the-data-science-life-cycle",
    "href": "m202-svi-ejscreen.html#the-data-science-life-cycle",
    "title": "EJSCREEN tool",
    "section": "The Data Science Life Cycle",
    "text": "The Data Science Life Cycle\nThe data science life cycle guides the systematic approach to handling data from collection to interpretation:\n\nData Acquisition\nObtain relevant datasets from sources like EJSCREEN, County Health Rankings, and specific studies’ databases. ### Data Preparation Clean and preprocess data to ensure accuracy and consistency, handling missing values and outliers appropriately.\n\n\nExploratory Data Analysis\nExplore data distributions, correlations, and initial insights to guide further analysis.\n\n\nModeling\nDevelop statistical models to test hypotheses and predict outcomes, considering factors like pollution exposure and demographic variables.\n\n\nEvaluation\nAssess model performance and validity through metrics and cross-validation techniques.\n\n\nDeployment\nCommunicate findings through reports, presentatio\nCongratulations! …. Now you should be able to:\n\nTest test…"
  },
  {
    "objectID": "m202-svi-ejscreen.html#lesson-3",
    "href": "m202-svi-ejscreen.html#lesson-3",
    "title": "EJSCREEN tool",
    "section": "Lesson 3",
    "text": "Lesson 3\nIn this lesson, we explored ….\nLesson 3"
  },
  {
    "objectID": "m203-grdiv1-pm25.html",
    "href": "m203-grdiv1-pm25.html",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "",
    "text": "In this lesson, you will use NASA socioeconomic and environmental Earthdata available at NASA SEDAC to compare relationships between levels of socioeconomic deprivation agaisnts air quality data of particulate matter (PM) in different international administrative areas.\nThis lesson walks through the process of calculating and visualizing zonal statistics for a set of countries using raster data, focusing on GRDI country quintiles and PM2.5 concentration levels within these quintile areas. It begins by subsetting data by country and iterating over each country to extract relevant zonal statistics like mean, median, and various percentiles for each quintile. These statistics are stored in a GeoDataFrame, which is later used to create a choropleth map that visualizes specific GRDI metrics across countries. The lesson includes a detailed analysis of PM2.5 concentrations within different GRDI quartiles for selected countries. This involves clipping the raster data to each country’s geometry, filtering the data based on the GRDI quartiles, and calculating the mean PM2.5 levels for each quartile. The results are then visualized using customized plots to highlight the relationship between air quality and GRDI metrics across the selected countries."
  },
  {
    "objectID": "m203-grdiv1-pm25.html#learning-objectives",
    "href": "m203-grdiv1-pm25.html#learning-objectives",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter completing this lesson, you should be able to:\n\nGain a general understanding of what is particulate matter (PM) in the air and how it impacts human health.\nLearn about global socioeconomic dimensions of deprivation and how they are spatially represented.\nFind statistical thresholds in socioeconomic data.\nPerform zonal statistics to summarize spatial data\nResample spatial data to harmoniza and compare socioeconomic data against environmental data.\nDisplay data on a maps to get a general understanding of the spatial distribution of data.\nSummarize spatial data into table plots to compare how air quality differs in different socioeconomic conditions of international administrative areas."
  },
  {
    "objectID": "m203-grdiv1-pm25.html#introduction",
    "href": "m203-grdiv1-pm25.html#introduction",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#data-collection-and-integration",
    "href": "m203-grdiv1-pm25.html#data-collection-and-integration",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Data Collection and Integration",
    "text": "Data Collection and Integration\nThe Global (GL) Annual PM2.5 Grids from MODIS, MISR and SeaWiFS Aerosol Optical Depth (AOD), v4.03 (1998 – 2019) can can be downloaded from the Socioeconomic Data and Applications Center ([SEDAC](https://sedac.ciesin.columbia.edu/)) (Center For International Earth Science Information Network-CIESIN-Columbia University 2022a).\nThe Global Gridded Relative Deprivation Index (GRDI), v1 (2010 – 2020) dataset can be downloaded from SEDAC as well (Center For International Earth Science Information Network-CIESIN-Columbia University 2022b).\nGather comprehensive datasets from reliable sources such as the US EPA’s EJSCREEN tool and other public health databases like John Hopkins and County Health Rankings. Integrate relevant environmental data (e.g., air pollutant concentrations, pollution source proximity) with health outcomes data (e.g., COVID-19 prevalence, NSCLC incidence). Ensure data compatibility and quality through data cleaning and validation procedures.\n\nPreparing Environment and Variables\nImporting python packages required:\n\nimport xarray as xr\nimport rioxarray\nimport rasterstats\nfrom rasterio.enums import Resampling\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport geopandas as gpd\nimport pygadm\n\nimport plotly.graph_objects as go \n\nLoad the GRDIv1 and PM2.5 data from local sources:\n\n# Load rasters\ngrdi_path = r\"Z:\\Sedac\\GRDI\\data\\povmap-grdi-v1-geotiff\\final data\\povmap-grdi-v1.tif\"\npm25_path = r\"F:\\TOPSSCHOOL\\git\\TOPSTSCHOOL-air-quality\\data\\sdei-global-annual-gwr-pm2-5-modis-misr-seawifs-aod-v4-gl-03-2019-geotiff\\sdei-global-annual-gwr-pm2-5-modis-misr-seawifs-aod-v4-gl-03-2019.tif\"\n\nUsing the package rasterio to load the data into memory. This allows us to read the data and use it for processing.\n\n# Open the input and reference rasters\ngrdi_raster = rioxarray.open_rasterio(grdi_path, mask_and_scale=True)\npm25_raster = rioxarray.open_rasterio(pm25_path, mask_and_scale=True)\n\n\n\nMatching Data Points using Bilinear Resample\nThe GRDI raster and PM2.5 rasters are incompatible in resolution. One method of harmonizing data is by using the Resampling bethod with a bilinear method. In this case, we reduce, or coarsen, the resolution of the GRDI raster to match the PM2.5 raster.\n\n# Resample the input raster to match the reference raster\ngrdi_raster = grdi_raster.rio.reproject_match(pm25_raster,resampling=Resampling.bilinear)"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#the-data-science-life-cycle",
    "href": "m203-grdiv1-pm25.html#the-data-science-life-cycle",
    "title": "EJSCREEN tool",
    "section": "The Data Science Life Cycle",
    "text": "The Data Science Life Cycle\nThe data science life cycle guides the systematic approach to handling data from collection to interpretation:\n\nData Acquisition\nObtain relevant datasets from sources like EJSCREEN, County Health Rankings, and specific studies’ databases. ### Data Preparation Clean and preprocess data to ensure accuracy and consistency, handling missing values and outliers appropriately.\n\n\nExploratory Data Analysis\nExplore data distributions, correlations, and initial insights to guide further analysis.\n\n\nModeling\nDevelop statistical models to test hypotheses and predict outcomes, considering factors like pollution exposure and demographic variables.\n\n\nEvaluation\nAssess model performance and validity through metrics and cross-validation techniques.\n\n\nDeployment\nCommunicate findings through reports, presentatio\nCongratulations! …. Now you should be able to:\n\nTest test…"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#module-2-air-quality-home",
    "href": "m203-grdiv1-pm25.html#module-2-air-quality-home",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Module 2: Air Quality Home",
    "text": "Module 2: Air Quality Home\nIn this lesson, we explored ….\nModule 2: Air Quality"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#previewing-spatial-data-in-a-plot",
    "href": "m203-grdiv1-pm25.html#previewing-spatial-data-in-a-plot",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Previewing Spatial Data in a Plot",
    "text": "Previewing Spatial Data in a Plot\n\n# Plotting the rasters\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 20))\n\n# Plot the original GRDI raster in the first subplot\nim1 = ax1.imshow(grdi_raster.values[0], cmap='viridis', interpolation='nearest')\nax1.set_title('Original GRDI Raster')\nfig.colorbar(im1, ax=ax1, orientation='horizontal', label='GRDI Values')\n\n# Plot the PM2.5 raster in the second subplot\nim2 = ax2.imshow(pm25_raster.values[0], cmap='hot', interpolation='nearest')\nax2.set_title('PM2.5 Raster')\nfig.colorbar(im2, ax=ax2, orientation='horizontal', label='PM2.5 Values')\n\n\n# Show the plots\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#working-with-administrative-data",
    "href": "m203-grdiv1-pm25.html#working-with-administrative-data",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Working with administrative Data",
    "text": "Working with administrative Data\npygadm is a package that has international administrative units from levels 0 to 2. We can search the available countries by listing the Names.\n\ncountry_table = gpd.GeoDataFrame(pygadm.Names())\nlen(country_table)\n\n263\n\n\nSome available areas with a unique GID_0 code share Names; therefore we drop the rows that contain digits.\n\ncountry_table = country_table[~country_table['GID_0'].str.contains('\\d', na=False)]\nlen(country_table)\n\n254\n\n\n\nSubset Data From a Table\nDoing Zonal statistics for more than 200 countries may take a while, therefore, we can subset the data randomly with the .sample() method.\n\ncountry_sample = country_table.sample(n=15)\ncountry_sample\n\n\n\n\n\n  \n    \n      \n      NAME_0\n      GID_0\n    \n  \n  \n    \n      251\n      Samoa\n      WSM\n    \n    \n      76\n      Fiji\n      FJI\n    \n    \n      72\n      Spain\n      ESP\n    \n    \n      200\n      Senegal\n      SEN\n    \n    \n      183\n      Philippines\n      PHL\n    \n    \n      231\n      Trinidad and Tobago\n      TTO\n    \n    \n      7\n      United Arab Emirates\n      ARE\n    \n    \n      226\n      Tajikistan\n      TJK\n    \n    \n      166\n      New Caledonia\n      NCL\n    \n    \n      260\n      Zambia\n      ZMB\n    \n    \n      112\n      British Indian Ocean Territory\n      IOT\n    \n    \n      77\n      Falkland Islands\n      FLK\n    \n    \n      259\n      South Africa\n      ZAF\n    \n    \n      139\n      Lithuania\n      LTU\n    \n    \n      212\n      South Sudan\n      SSD"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#zonal-statistics-for-each-administrative-area",
    "href": "m203-grdiv1-pm25.html#zonal-statistics-for-each-administrative-area",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Zonal Statistics for Each Administrative Area",
    "text": "Zonal Statistics for Each Administrative Area\nrasterstats has a funcion zonal_stats() which allows you to use vectors to summarize raster data. We summarize GRDIv1 data to calculate the following statistics: count, minimum, mean, max, median, standard deviation, range, and percentiles 20, 40, 60, and 80.\n\nstats_results = gpd.GeoDataFrame()\n\nfor index, row in country_sample.iloc[:].iterrows():\n    country = row['NAME_0']\n    country_GID = row['GID_0']\n    try:\n        country_poly =  pygadm.Items(admin=country_GID, content_level=0)\n    except:\n        print(country, \" skipped.\")\n        continue\n\n    # Create a mask for the polygons\n    grdi_country_zs= rasterstats.zonal_stats(country_poly, grdi_raster.values[0], affine=grdi_raster.rio.transform(), stats=\"count min mean max median std median range percentile_20 percentile_40 percentile_60 percentile_80\")\n    # # pm25_country_zs= rasterstats.zonal_stats(country_poly, pm25_arr, affine=pm25_transform, stats=\"count min mean max median std median range percentile_20 percentile_40 percentile_60 percentile_80\", nodata=pm25_raster.nodata)\n    # # Extract statistics into a dictionary\n    country_stats = {\n        'Country_Name': country,\n        'Country_GID' : country_GID,\n        'GRDI_Count': grdi_country_zs[0]['count'],\n        'GRDI_Min': grdi_country_zs[0]['min'],\n        'GRDI_Mean': grdi_country_zs[0]['mean'],\n        'GRDI_Max': grdi_country_zs[0]['max'],\n        'GRDI_Median': grdi_country_zs[0]['median'],\n        'GRDI_Std': grdi_country_zs[0]['std'],\n        'GRDI_Range': grdi_country_zs[0]['range'],\n        'GRDI_P20': grdi_country_zs[0]['percentile_20'],\n        'GRDI_P40': grdi_country_zs[0]['percentile_40'],\n        'GRDI_P60': grdi_country_zs[0]['percentile_60'],\n        'GRDI_P80': grdi_country_zs[0]['percentile_80'],\n        #     # 'PM25_Count': pm25_country_zs[0]['count'],\n        #     # 'PM25_Min': pm25_country_zs[0]['min'],\n        # 'PM25_Mean': pm25_country_zs[0]['mean'],\n        #     # 'PM25_Max': pm25_country_zs[0]['max'],\n        #     # 'PM25_Median': pm25_country_zs[0]['median'],\n        #     # 'PM25_Std': pm25_country_zs[0]['std'],\n        #     # 'PM25_Range': pm25_country_zs[0]['range'],\n        #     # 'PM25_P20': pm25_country_zs[0]['percentile_20'],\n        #     # 'PM25_P40': pm25_country_zs[0]['percentile_40'],\n        #     # 'PM25_P60': pm25_country_zs[0]['percentile_60'],\n        #     # 'PM25_P80': pm25_country_zs[0]['percentile_80'],\n        'geometry' : country_poly['geometry'].iloc[0]\n    }\n    country_stats_gdf = gpd.GeoDataFrame([country_stats], geometry='geometry')\n    # stats_results.append(country_stats_gdf)\n    stats_results = pd.concat([stats_results, country_stats_gdf], ignore_index=True)\n\nLet’s use the .head() method from Pandas to check the top of our table\n\nstats_results.head()\n\n\n\n\n\n  \n    \n      \n      Country_Name\n      Country_GID\n      GRDI_Count\n      GRDI_Min\n      GRDI_Mean\n      GRDI_Max\n      GRDI_Median\n      GRDI_Std\n      GRDI_Range\n      GRDI_P20\n      GRDI_P40\n      GRDI_P60\n      GRDI_P80\n      geometry\n    \n  \n  \n    \n      0\n      Samoa\n      WSM\n      893\n      16.779119\n      72.627572\n      82.130798\n      75.354385\n      9.305466\n      65.351679\n      69.140343\n      73.877106\n      76.735214\n      79.172623\n      MULTIPOLYGON (((-171.4079 -14.0746, -171.4055 ...\n    \n    \n      1\n      Fiji\n      FJI\n      4899\n      11.950370\n      72.009945\n      86.728622\n      74.518845\n      9.951100\n      74.778253\n      69.718742\n      73.071259\n      75.752144\n      77.892212\n      MULTIPOLYGON (((178.1063 -19.1592, 178.1064 -1...\n    \n    \n      2\n      Spain\n      ESP\n      302383\n      2.526078\n      53.366115\n      72.849083\n      58.745010\n      12.811808\n      70.323005\n      47.256508\n      56.190113\n      60.127953\n      62.182636\n      MULTIPOLYGON (((-17.9632 27.6904, -17.9657 27....\n    \n    \n      3\n      Senegal\n      SEN\n      32706\n      26.157717\n      85.125428\n      99.563820\n      88.179062\n      9.393603\n      73.406103\n      83.247147\n      86.728622\n      88.949966\n      89.592674\n      MULTIPOLYGON (((-15.9534 12.4426, -16.0378 12....\n    \n    \n      4\n      Philippines\n      PHL\n      134581\n      6.626353\n      72.399834\n      91.909012\n      75.517365\n      11.636341\n      85.282659\n      68.165047\n      73.975517\n      76.879448\n      79.703705\n      MULTIPOLYGON (((119.4706 4.5911, 119.4689 4.58..."
  },
  {
    "objectID": "m203-grdiv1-pm25.html#defining-a-funtion",
    "href": "m203-grdiv1-pm25.html#defining-a-funtion",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Defining a Funtion",
    "text": "Defining a Funtion\nWe can create a custom function that can allow us to use the zonal statistics process multiple times. A custom function can be created using the def FUNCTION_NAME(PARAMETER1, PARAMETER2): fuction to define what the fucntion will do.\n\ndef calculate_country_stats(country_sample, grdi_raster, pm25_raster=None):\n    \"\"\"\n    Calculate statistics for each country in the sample.\n\n    Parameters:\n    - country_sample: A pandas DataFrame containing country information with 'NAME_0' and 'GID_0' columns, in this case the country_table.\n    - grdi_raster: A raster object with which to perform the zonal statistics.\n    - pm25_raster: (Optional) A raster object for PM2.5 data. If provided, statistics will also be calculated for this raster.\n\n    Returns:\n    - stats_results: A GeoDataFrame containing the statistics for each country.\n    \"\"\"\n    stats_results = gpd.GeoDataFrame()\n\n    for index, row in country_sample.iloc[:].iterrows():\n        country = row['NAME_0']\n        country_GID = row['GID_0']\n        try:\n            country_poly = pygadm.Items(admin=country_GID, content_level=0)\n        except Exception as e:\n            print(country, \"skipped due to error:\", e)\n            continue\n\n        # Create a mask for the polygons and perform zonal statistics on GRDI raster\n        grdi_country_zs = rasterstats.zonal_stats(\n            country_poly, grdi_raster.values[0], \n            affine=grdi_raster.rio.transform(), \n            stats=\"count min mean max median std range percentile_20 percentile_40 percentile_60 percentile_80\"\n        )\n\n        # Uncomment and update the following lines if you want to include PM2.5 statistics\n        # if pm25_raster is not None:\n        #     pm25_country_zs = rasterstats.zonal_stats(\n        #         country_poly, pm25_raster.values[0], \n        #         affine=pm25_raster.rio.transform(), \n        #         stats=\"count min mean max median std range percentile_20 percentile_40 percentile_60 percentile_80\", \n        #         nodata=pm25_raster.nodata\n        #     )\n\n        # Extract statistics into a dictionary\n        country_stats = {\n            'Country_Name': country,\n            'Country_GID' : country_GID,\n            'GRDI_Count': grdi_country_zs[0]['count'],\n            'GRDI_Min': grdi_country_zs[0]['min'],\n            'GRDI_Mean': grdi_country_zs[0]['mean'],\n            'GRDI_Max': grdi_country_zs[0]['max'],\n            'GRDI_Median': grdi_country_zs[0]['median'],\n            'GRDI_Std': grdi_country_zs[0]['std'],\n            'GRDI_Range': grdi_country_zs[0]['range'],\n            'GRDI_P20': grdi_country_zs[0]['percentile_20'],\n            'GRDI_P40': grdi_country_zs[0]['percentile_40'],\n            'GRDI_P60': grdi_country_zs[0]['percentile_60'],\n            'GRDI_P80': grdi_country_zs[0]['percentile_80'],\n            'geometry' : country_poly['geometry'].iloc[0]\n        }\n\n        # If PM2.5 statistics are calculated, add them to the dictionary\n        # if pm25_raster is not None:\n        #     country_stats.update({\n        #         'PM25_Count': pm25_country_zs[0]['count'],\n        #         'PM25_Min': pm25_country_zs[0]['min'],\n        #         'PM25_Mean': pm25_country_zs[0]['mean'],\n        #         'PM25_Max': pm25_country_zs[0]['max'],\n        #         'PM25_Median': pm25_country_zs[0]['median'],\n        #         'PM25_Std': pm25_country_zs[0]['std'],\n        #         'PM25_Range': pm25_country_zs[0]['range'],\n        #         'PM25_P20': pm25_country_zs[0]['percentile_20'],\n        #         'PM25_P40': pm25_country_zs[0]['percentile_40'],\n        #         'PM25_P60': pm25_country_zs[0]['percentile_60'],\n        #         'PM25_P80': pm25_country_zs[0]['percentile_80'],\n        #     })\n\n        country_stats_gdf = gpd.GeoDataFrame([country_stats], geometry='geometry')\n        stats_results = pd.concat([stats_results, country_stats_gdf], ignore_index=True)\n\n    return stats_results\n\nFrom the table above, we can choose an attribute, or column, to display it in a map plot. In this case, I’m choosing the GRDI Max\n\ncolumn_chosen = 'GRDI_Max' #GRDI_Max, GRDI_Min, GRDI_Median\n# Plotting\nfig, ax = plt.subplots(1, 1, figsize=(15, 10))\nstats_results.plot(column=column_chosen, ax=ax, legend=True,\n    legend_kwds={'label': f\"{column_chosen} per country.\",\n                      'orientation': \"horizontal\"})\nax.set_title('Choropleth Map Showing GRDI Mean per country')\nax.set_axis_off()  # Turn off the axis numbers and ticks\nplt.show()\n\n\n\n\n\nSelecting Data by Column\nStart my creating a list of countries that you are interested in to Subset data from the DataFrame that match the values in the NAME_0 column. The .isin() mehthod checks each element in the DataFrame’s column for the item present in the list and returns matching rows.\n\n# selected_countries = [\"Algeria\", \"Somalia\", \"Colombia\", \"Timor Leste\", \"Finland\", \"Nicaragua\", \"United Kingdom\", \"Mali\"]\n# selected_countries = [\"Anguilla\", \"Armenia\", \"Angola\", \"Argentina\", \"Albania\", \"United Arab Emirates\", \"American Samoa\", \"Australia\" ]\nselected_countries = [\"Algeria\", \"Somalia\", \"Colombia\", \"Timor Leste\", \"Finland\", \"Nicaragua\", \"United Kingdom\", \"Mali\", \"Armenia\", \"Argentina\",  \"Albania\", \"United Arab Emirates\", \"Indonesia\", \"Qatar\"]\n\n#use the list above to subset the country_table DataFrame by the column NAME_0 \nselected_countries = country_table[country_table['NAME_0'].isin(selected_countries)]\n\n\n\nUsing a Defined Custom Function\nRecalling the defined fucntion calculate_country_stats, we can use our selected_countries list, and the GRDI and PM2.5 rasters, to create a new table of zonal statistics.\n\nstats_results = calculate_country_stats(selected_countries, grdi_raster)\n\nShow the head of the table again:\n\nstats_results.head()\n\n\n\n\n\n  \n    \n      \n      Country_Name\n      Country_GID\n      GRDI_Count\n      GRDI_Min\n      GRDI_Mean\n      GRDI_Max\n      GRDI_Median\n      GRDI_Std\n      GRDI_Range\n      GRDI_P20\n      GRDI_P40\n      GRDI_P60\n      GRDI_P80\n      geometry\n    \n  \n  \n    \n      0\n      Albania\n      ALB\n      19076\n      8.272310\n      61.513866\n      75.395561\n      66.220139\n      11.644754\n      67.123251\n      55.861691\n      64.445587\n      67.104332\n      68.589424\n      MULTIPOLYGON (((20.0541 39.6917, 20.0389 39.69...\n    \n    \n      1\n      United Arab Emirates\n      ARE\n      18229\n      5.732072\n      42.347647\n      67.470955\n      45.034630\n      17.949307\n      61.738883\n      24.688160\n      38.623692\n      50.710217\n      61.909931\n      MULTIPOLYGON (((54.1541 22.7548, 53.3313 22.85...\n    \n    \n      2\n      Argentina\n      ARG\n      474297\n      7.572341\n      66.341158\n      81.701645\n      68.789696\n      10.416561\n      74.129304\n      66.774643\n      68.278297\n      69.335510\n      71.098465\n      MULTIPOLYGON (((-66.5458 -55.061, -66.5486 -55...\n    \n    \n      3\n      Armenia\n      ARM\n      9108\n      6.944193\n      59.871617\n      73.707901\n      64.272858\n      12.315193\n      66.763708\n      52.692970\n      61.288189\n      66.743027\n      69.004845\n      MULTIPOLYGON (((45.8319 39.8311, 45.8448 39.82...\n    \n    \n      4\n      Colombia\n      COL\n      223557\n      11.956444\n      71.523674\n      84.922409\n      73.350586\n      8.762370\n      72.965965\n      69.966934\n      72.190056\n      74.405403\n      76.502792\n      MULTIPOLYGON (((-77.491 4.1451, -77.4985 4.140...\n    \n  \n\n\n\n\nPlot the map again choosing a column to plot:\n\ncolumn_chosen = 'GRDI_Max' #GRDI_Max, GRDI_Min, GRDI_Median\nstats_results.plot(column=column_chosen, legend=True)\nplt.show()"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#creating-a-table-with-results",
    "href": "m203-grdiv1-pm25.html#creating-a-table-with-results",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Creating a Table with Results",
    "text": "Creating a Table with Results\nWe can create a list of tuples that we can use to refer to the GRDI statistical values, and the name, color, and symbol we want to assign. In this case, we are using the GRDI zonal statistics of each country we selected that include the Mean, Minimum, Maximum, and interquartiles.\n\n# List of GRDI values and their corresponding properties\n#column, value name, color, symbol\ngrdi_data = [\n    ('GRDI_Mean', 'Mean', 'orange', 'diamond'),\n    ('GRDI_Min', 'Min', 'gray', '152'),\n    ('GRDI_Max', 'Max', 'gray', '151'),\n    ('GRDI_P20', 'Q20', 'blue', '142'),\n    ('GRDI_P40', 'Q40', 'purple', '142'),\n    ('GRDI_P60', 'Q60', 'green', '142'),\n    ('GRDI_P80', 'Q80', 'red', '142')\n]\n\nWe can create a figure to display the data based on the names colors and symbols we selected.\n\n# Create a figure\nfig = go.Figure()\n\n# Add traces to the figure based on the data\nfor col, name, color, symbol in grdi_data:\n    fig.add_trace(go.Scatter(\n        x=stats_results[col],\n        y=stats_results['Country_Name'],\n        mode='markers',\n        name=name,\n        marker=dict(color=color, size=10, symbol=symbol)\n    ))\n\n# Customize layout\nfig.update_layout(\n    title='GRDI Statistics by Country',\n    xaxis_title='GRDI Values',\n    yaxis_title='Country Name',\n    yaxis=dict(tickmode='linear'),\n    legend_title='Statistics',\n    yaxis_type='category',\n    xaxis=dict(tickvals=[0, 20, 40, 60, 80, 100])\n)\n\n# Show plot\nfig.show()"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#summarizing-pm2.5-values-by-socioeconomic-deprivation",
    "href": "m203-grdiv1-pm25.html#summarizing-pm2.5-values-by-socioeconomic-deprivation",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Summarizing PM2.5 Values by Socioeconomic Deprivation",
    "text": "Summarizing PM2.5 Values by Socioeconomic Deprivation\nConsidering the GRDI quartile values as a level of socieoeconomic deprivation within each country, we can use the stats_results GeoDataFrame, the GRDI raster, and the PM2.5 raster to calculate the Mean PM.25 value within each of those areas in each country. This can describe how the air quality for different socioeconomic strata compare within the country, as well as against other countries.\nThe results will be added to the stats_results with the corresponting columns.\n\n# iterate through the stats_results table rows\nfor index, row in stats_results.iloc[:].iterrows():\n    #isolate each country's respective row\n    row_df = gpd.GeoDataFrame([row], geometry='geometry').reset_index(drop=True)\n    print(row_df.loc[0,'Country_GID'])\n    try:\n        #use rioxarray to clip the GRDI and PM2.5 rasters by the geometry of the respective country.\n        grdi_country = grdi_raster.rio.clip(row_df.geometry, grdi_raster.rio.crs)\n        pm25_country = pm25_raster.rio.clip(row_df.geometry, grdi_raster.rio.crs)\n    except:\n        print('Error in clip')\n        continue\n\n    #Applying squeeze() to this array removes the singleton dimension, reducing it to a 2D array with dimensions (rows, columns)\n    grdi_country= grdi_country.squeeze()\n    pm25_country= pm25_country.squeeze()\n\n\n    # Subset the GRDI raster where values fall between each GRDI quintiles\n    grdi_countryQ1 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_Min']) & (grdi_country <= row_df.loc[0, 'GRDI_P20']))\n    grdi_countryQ2 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_P20']) & (grdi_country <= row_df.loc[0, 'GRDI_P40']))\n    grdi_countryQ3 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_P40']) & (grdi_country <= row_df.loc[0, 'GRDI_P60']))\n    grdi_countryQ4 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_P60']) & (grdi_country <= row_df.loc[0, 'GRDI_P80']))\n    grdi_countryQ5 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_P80']) & (grdi_country <= row_df.loc[0, 'GRDI_Max']))\n\n\n    # Mask the PM2.5 raster using the above GRDI quartile rasters, keeping only the cells that intersect\n    pm25_countryQ1 = pm25_country.where(grdi_countryQ1.notnull())\n    pm25_countryQ2 = pm25_country.where(grdi_countryQ2.notnull())\n    pm25_countryQ3 = pm25_country.where(grdi_countryQ3.notnull())\n    pm25_countryQ4 = pm25_country.where(grdi_countryQ4.notnull())\n    pm25_countryQ5 = pm25_country.where(grdi_countryQ5.notnull())\n\n    #Find the mean value of of the intersected PM2.5 rasters in each quartile\n    pm25_countryQ1v = pm25_countryQ1.mean().item()\n    pm25_countryQ2v = pm25_countryQ2.mean().item()\n    pm25_countryQ3v = pm25_countryQ3.mean().item()\n    pm25_countryQ4v = pm25_countryQ4.mean().item()\n    pm25_countryQ5v = pm25_countryQ5.mean().item()\n\n    #add the resuts to the stats_results table in the respective column\n    stats_results.at[index, 'PM25_Q1'] = pm25_countryQ1v\n    stats_results.at[index, 'PM25_Q2'] = pm25_countryQ2v\n    stats_results.at[index, 'PM25_Q3'] = pm25_countryQ3v\n    stats_results.at[index, 'PM25_Q4'] = pm25_countryQ4v\n    stats_results.at[index, 'PM25_Q5'] = pm25_countryQ5v\n\nALB\n\n\nARE\n\n\nARG\n\n\nARM\n\n\nCOL\n\n\nDZA\n\n\nFIN\n\n\nGBR\n\n\nIDN\n\n\nMLI\n\n\nNIC\n\n\nQAT\n\n\nSOM\n\n\n\nstats_results.head()\n\n\n\n\n\n  \n    \n      \n      Country_Name\n      Country_GID\n      GRDI_Count\n      GRDI_Min\n      GRDI_Mean\n      GRDI_Max\n      GRDI_Median\n      GRDI_Std\n      GRDI_Range\n      GRDI_P20\n      GRDI_P40\n      GRDI_P60\n      GRDI_P80\n      geometry\n      PM25_Q1\n      PM25_Q2\n      PM25_Q3\n      PM25_Q4\n      PM25_Q5\n    \n  \n  \n    \n      0\n      Albania\n      ALB\n      19076\n      8.272310\n      61.513866\n      75.395561\n      66.220139\n      11.644754\n      67.123251\n      55.861691\n      64.445587\n      67.104332\n      68.589424\n      MULTIPOLYGON (((20.0541 39.6917, 20.0389 39.69...\n      15.438293\n      15.031855\n      14.699892\n      14.612475\n      15.709009\n    \n    \n      1\n      United Arab Emirates\n      ARE\n      18229\n      5.732072\n      42.347647\n      67.470955\n      45.034630\n      17.949307\n      61.738883\n      24.688160\n      38.623692\n      50.710217\n      61.909931\n      MULTIPOLYGON (((54.1541 22.7548, 53.3313 22.85...\n      47.710175\n      47.893559\n      47.822292\n      48.220722\n      49.729328\n    \n    \n      2\n      Argentina\n      ARG\n      474297\n      7.572341\n      66.341158\n      81.701645\n      68.789696\n      10.416561\n      74.129304\n      66.774643\n      68.278297\n      69.335510\n      71.098465\n      MULTIPOLYGON (((-66.5458 -55.061, -66.5486 -55...\n      7.519970\n      5.924110\n      6.083218\n      7.562082\n      8.672854\n    \n    \n      3\n      Armenia\n      ARM\n      9108\n      6.944193\n      59.871617\n      73.707901\n      64.272858\n      12.315193\n      66.763708\n      52.692970\n      61.288189\n      66.743027\n      69.004845\n      MULTIPOLYGON (((45.8319 39.8311, 45.8448 39.82...\n      19.292490\n      16.728804\n      16.334721\n      16.337336\n      15.342737\n    \n    \n      4\n      Colombia\n      COL\n      223557\n      11.956444\n      71.523674\n      84.922409\n      73.350586\n      8.762370\n      72.965965\n      69.966934\n      72.190056\n      74.405403\n      76.502792\n      MULTIPOLYGON (((-77.491 4.1451, -77.4985 4.140...\n      27.425064\n      29.047859\n      24.132767\n      22.309097\n      20.367249"
  },
  {
    "objectID": "m203-grdiv1-pm25.html#plot-results-of-mean-pm2.5-in-socieceonomic-deprivation-quartiles-per-country",
    "href": "m203-grdiv1-pm25.html#plot-results-of-mean-pm2.5-in-socieceonomic-deprivation-quartiles-per-country",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Plot Results of Mean PM2.5 in Socieceonomic Deprivation Quartiles per country",
    "text": "Plot Results of Mean PM2.5 in Socieceonomic Deprivation Quartiles per country\nSimilarly, we create a list of tuples of how we want to display the data, and create a figure based on the tuples. This plot would show each country in the y axis and the Log of Mean PM2.5 values in each country’s GRDI quarties.\n\n# List of GRDI values and their corresponding properties\n#column, value name, color, symbol\nplot_data =[\n    ('PM25_Q1', 'Q1', '#440154', '6'),  # Light Blue\n    ('PM25_Q2', 'Q2', '#31688E', '5'),  # Light Green\n    ('PM25_Q3', 'Q3', '#35B779', '7'),  # Yellow\n    ('PM25_Q4', 'Q4', '#FDE725', '8'),  # Orange\n    ('PM25_Q5', 'Q5', '#FF0000', '1')   # Red\n]\n\n# Create a figure\nfig = go.Figure()\n\n# Add traces to the figure.\nfor col, name, color, symbol in plot_data:\n    xlog  = np.log(stats_results[col])\n    fig.add_trace(go.Scatter(\n        x=xlog,\n        y=stats_results['Country_Name'],\n        mode='markers+text',  # Add 'text' to mode\n        text=[f'<b>{name}</b>' for _ in stats_results[col]],  # Repeat name for each point\n        name=name,\n        textfont=dict(color=color, size=12),\n        textposition='top center',  # Position the text above the symbol\n        marker_color=color,\n        marker_line_color=\"midnightblue\",\n        marker_symbol=symbol,\n        marker_size=14,\n        marker_line_width=2,\n        marker_opacity=0.6\n        ))\nfig.update_traces(textposition='top center')\n\n    # Customize layout\nfig.update_layout(\n    title='Mean PM2.5 in each GRDI Quartile by Country',\n    xaxis_title='Log of PM2.5 Mean Values',\n    yaxis_title='Country Name',\n    yaxis=dict(tickmode='linear'),\n    legend_title='Statistics',\n    yaxis_type='category',\n    xaxis=dict(rangemode=\"tozero\"),\n    \n    #xaxis=dict(tickvals=[0, 20, 40, 60, 80, 100])\n    )\n\n# Show plot\nfig.show()\n\n\n                                                \n\n\nUse the plotly controls to take a closer look at the results.\nWith this shapely plot, We can examine differences between countires and PM2.5 values. The plot displays the coutnries on the Y axis and log values of the average PM2.5 value on the X axis. Each country displays PM2.5 values averaged within the quartile areas based on GRDI values of each country. A higher quartile (Q) implies a higher degree of deprivation, 1 being the lowest and 5 the highest.\nCongratulations! …. Now you should be able to:\n\nTest test…"
  },
  {
    "objectID": "m202-svi-tri-icis-places.html",
    "href": "m202-svi-tri-icis-places.html",
    "title": "Exploring SVI, TRI, and Health Outcomes",
    "section": "",
    "text": "In this lesson, we will introduce you to 3 public health and air quality datasets. These include the EPA’s Toxic Release Inventory (TRI), the EPA’s Integrated Compliance Information System for Air (ICIS-AIR), and the CDC’s PLACES health outcomes dataset. You will learn how to form queries and retrieve each dataset from their respective API, process the returned object into a useable format, create visualizations and perform simple analysis. You will also use NASA’s Social Vulnerability Index (SVI) to examine socioeconomic patterns in the greater Detroit metropolitan area and explore relationships with public health.\n\n\n\n\n\n\nProgramming Reminder\n\n\n\nThis lesson uses the Python programming environment."
  },
  {
    "objectID": "m202-svi-tri-icis-places.html#overview",
    "href": "m202-svi-tri-icis-places.html#overview",
    "title": "Exploring SVI, TRI, and Health Outcomes",
    "section": "",
    "text": "In this lesson, we will introduce you to 3 public health and air quality datasets. These include the EPA’s Toxic Release Inventory (TRI), the EPA’s Integrated Compliance Information System for Air (ICIS-AIR), and the CDC’s PLACES health outcomes dataset. You will learn how to form queries and retrieve each dataset from their respective API, process the returned object into a useable format, create visualizations and perform simple analysis. You will also use NASA’s Social Vulnerability Index (SVI) to examine socioeconomic patterns in the greater Detroit metropolitan area and explore relationships with public health.\n\n\n\n\n\n\nProgramming Reminder\n\n\n\nThis lesson uses the Python programming environment."
  },
  {
    "objectID": "m202-svi-tri-icis-places.html#learning-objectives",
    "href": "m202-svi-tri-icis-places.html#learning-objectives",
    "title": "Exploring SVI, TRI, and Health Outcomes",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter completing this lesson, you should be able to:\n\nRetrieve multiple public health datasets through the EPA and CDC’s APIs.\nCreate multipanel raster maps from multilayered SVI data.\nGeolocating tabular data using latitude and longitude.\nCreate maps joining geolocated points and basemaps.\nCreate maps with graduated point symbols for point source pollution releases.\nInterpolate a raster surface from point spatial data.\nPerform raster math to create specialized indexes.\nPerform spatial correlation analysis.\n\n\n\n\n\n\n\nPreface: A Note on Data Interpretation and Ethical Considerations\n\n\n\nThis lesson is designed to introduce you to various environmental, public health, and socioeconomic datasets, and to provide you with the tools to analyze and visualize this information. However, it’s crucial to approach this material with an understanding of its sensitive nature and potential implications.\nThe topics of environmental justice, institutional racism, socioeconomic conditions, and pollution are complex and multifaceted. The data and analyses presented in this lesson are not intended to draw definitive conclusions or suggest scientific evidence of cause and effect relationships. Rather, they are meant to equip you with the skills to investigate data and perform analyses that could be applied to your local communities.\nAs you work through this lesson, remember that correlation does not imply causation. The patterns you may observe in the data could be influenced by numerous factors not captured in these datasets. It’s essential to approach your findings with caution and to consider the broader historical, social, and economic contexts that shape environmental and health outcomes in different communities.\nThis lesson aims to empower you with data literacy and analytical skills. We encourage you to use these tools responsibly, always considering the ethical implications of your analyses and the potential impact on the communities represented in the data. When drawing insights or making decisions based on such analyses, it’s crucial to involve community stakeholders, consider multiple perspectives, and seek additional expertise when necessary."
  },
  {
    "objectID": "m202-svi-tri-icis-places.html#introduction",
    "href": "m202-svi-tri-icis-places.html#introduction",
    "title": "Exploring SVI, TRI, and Health Outcomes",
    "section": "Introduction",
    "text": "Introduction\nIn many urban areas, air quality issues disproportionately affect low-income communities and communities of color. This disparity is a key focus of environmental justice efforts. In cities like Detroit, Chicago, and Cleveland industrial facilities, highways, and other pollution sources are often concentrated in disadvantaged neighborhoods. Detroit has a history of industrial pollution and is working to address air quality issues in areas like Southwest Detroit, where residents face higher exposure to pollutants from nearby industries and heavy truck traffic. Similarly, Chicago has seen community efforts to address air pollution in areas like the Southeast Side, where residents have fought against polluting industries and advocated for stricter regulations.\nThe EPA is the primary federal agency responsible for environmental protection in the United States. It sets and enforces air quality standards, including the National Ambient Air Quality Standards (NAAQS) for six criteria pollutants. The EPA also maintains the AirNow system, which provides real-time air quality data to the public. CDC (Centers for Disease Control and Prevention): While primarily focused on public health, the CDC plays a crucial role in understanding the health impacts of air pollution. It conducts research on the relationships between air quality and various health outcomes, and provides guidance on protecting public health from environmental hazards.\nIn response to these challenges, community-driven science initiatives have emerged. These efforts involve local residents in collecting data on air quality and other environmental factors, often using low-cost sensors and mobile monitoring techniques. This approach helps fill gaps in official monitoring networks and empowers communities to advocate for themselves. Open data is crucial for community-driven solutions in several ways:\n\nTransparency: Open data allows communities to verify official reports and hold authorities accountable.\nAccessibility: When air quality data is freely available, communities can use it to inform local decision-making and advocacy efforts.\nInnovation: Open data enables researchers, activists, and tech developers to create new tools and analyses that can benefit communities.\nCollaboration: Open data facilitates collaboration between communities, scientists, and policymakers, leading to more effective solutions.\n\nWhile the EPA and CDC provide federal networks of open-access datasets like the Air Quality System (AQS), TRI, ICIS-AIR, and PLACES collections, community driven data collection is a large part of driving change in traditionally underrepresented communities. In Chicago, the Array of Things project has installed sensors throughout the city, providing open data on various environmental factors including air quality, while Detroit’s Community Air Monitoring Project uses low-cost sensors to collect and share air quality data in areas underserved by official monitoring stations.\nWith access to open data, communities can:\n\nIdentify local air quality hotspots that may be missed by sparse official monitoring networks.\nCorrelate air quality data with health outcomes to strengthen advocacy efforts.\nDevelop targeted interventions, such as promoting indoor air filtration on high-pollution days.\nCreate custom alerts and information systems tailored to local needs.\n\nAlthough open data provides many benefits, challenges still remain. These include: 1) ensuring data quality and consistency, especially when integrating data from various sources; 2) addressing the “digital divide” to ensure all community members can access and use the data; 3) balancing the need for detailed local data with privacy concerns; and 4) building capacity within communities to effectively use and interpret complex environmental data.\n\n\n\n\n\n\nEJ in the News\n\n\n\nThe Clear the Air Coalition, a new environmental justice advocacy group in Michigan, is calling for stronger protection of vulnerable communities from pollution. Launched in Detroit, the coalition argues that state regulators focus too much on technical compliance with environmental laws rather than public health. They claim the current permitting process favors polluters and fails to consider the cumulative impacts of pollution on overburdened communities. The group seeks changes in state law and a shift in mindset from environmental regulators.\n\n\n\nClear the Air Coalition\n\n\nWhile the Michigan Department of Environment, Great Lakes, and Energy (EGLE) states its commitment to protecting underserved communities and notes improvements in air quality over recent decades, coalition members argue that the current approach is insufficient. They call for regulators to consider the combined effects of multiple pollution sources in marginalized areas and to give local governments more power to reject new polluting facilities in already burdened communities. The coalition plans to raise awareness and push for these changes during the upcoming Air Quality Awareness Week.\n\n\nThe state of Michigan, Department of Environment, Great Lakes, and Energy (EGLE), and the Office of the Environmental Justice Public Advocate are one of the most active state departments aiming to address issues of the environment, public health, and social justice. Here are some of the projects enacted in greater Detroit area:\n\nDetroit Environmental Agenda: This community-led initiative works closely with EGLE to address environmental concerns in Detroit. It focuses on issues like air quality, water quality, and waste management.\n48217 Community Air Monitoring Project: Named after the zip code of a heavily industrialized area in Southwest Detroit, this project involves community members working with EGLE to monitor air quality using low-cost sensors.\nDetroit Climate Action Plan: Developed in partnership with EGLE, this plan addresses climate change impacts on the city, with a focus on vulnerable communities.\nDelray Neighborhood Initiatives: EGLE has been involved in efforts to address air quality concerns in the Delray neighborhood, which is impacted by industrial emissions and heavy truck traffic.\nGreen Door Initiative: This Detroit-based organization collaborates with EGLE on various environmental justice projects, including lead abatement and air quality improvement efforts.\nDetroit River Sediment Cleanup: EGLE has been involved in efforts to clean up contaminated sediments in the Detroit River, which disproportionately affects nearby low-income communities.\nAsthma Prevention Programs: EGLE supports community-based asthma prevention programs in Detroit, recognizing the link between air quality and asthma rates in disadvantaged neighborhoods.\n\nThese are just a few of examples that demonstrate the ongoing collaboration between community groups, local government, and EGLE to address environmental justice concerns in Detroit.\nAir quality issues in urban areas disproportionately affect low-income communities and communities of color, making it a critical focus for environmental justice efforts. Federal agencies like the EPA and CDC play crucial roles in setting standards and conducting research, but community-driven science initiatives have emerged as powerful tools for local action. Open data is key to these efforts, enabling transparency, accessibility, innovation, and collaboration. Cities like Detroit and Chicago are at the forefront of these initiatives, with projects that empower residents to monitor and advocate for better air quality. While challenges remain, particularly in data management and accessibility, the collaboration between community groups, local governments, and state agencies like Michigan’s EGLE demonstrates a promising path forward."
  },
  {
    "objectID": "m202-svi-tri-icis-places.html#data-analysis-and-exercises",
    "href": "m202-svi-tri-icis-places.html#data-analysis-and-exercises",
    "title": "Exploring SVI, TRI, and Health Outcomes",
    "section": "Data Analysis and Exercises",
    "text": "Data Analysis and Exercises\nTo better understand and address these complex issues, we’ll work through a series of coding and data science exercises. These hands-on activities will allow users to explore some of the open datasets and tools that are available to community members and stakeholders that offer practical insights into air quality, public health, and social vulnerability.\nWe’ll begin with the ICIS-AIR dataset, then move on to the TRI Facility dataset, and finally work our way down to TRI Form A. After exploring these 3 air pollution datasets, we will take a look at the CDC PLACES health outcomes data and perform some simple analysis integrating the pollution and health outcomes data.\n\n\n\n\n\n\nData Science Review\n\n\n\nThis lesson uses the following Python modules:\n\npandas: Essential for data manipulation and analysis.\ngeopandas: Extends pandas functionality to handle geospatial data.\nmatplotlib: Used for creating static, animated, and interactive visualizations.\nnumpy: Provides support for large, multi-dimensional arrays and matrices, along with mathematical functions to operate on these arrays.\nrequests: Allows you to send HTTP requests and interact with APIs easily.\ncontextily: Adds basemaps to your plots, enhancing the visual context of your geospatial data.\npygris: Simplifies the process of working with US Census Bureau TIGER/Line shapefiles.\nrasterio: Reads and writes geospatial raster datasets.\nxarray: Introduces labels in the form of dimensions, coordinates, and attributes on top of raw NumPy-like arrays, making it easier to work with labeled multi-dimensional arrays.\nshapely: Manipulation and analysis of geometric objects in the Cartesian plane.\nscipy: Used for scientific and technical computing, particularly the stats and interpolate submodules.\nrioxarray: Extends xarray to make it easier to handle geospatial raster data.\ntime: Provides various time-related functions (part of Python’s standard library).\ntabulate: Used for creating nicely formatted tables in various output formats.\npysal: A library of spatial analysis functions.\nsplot: Provides statistical plots for spatial analysis.\n\nIf you’d like to learn more about the functions used in this lesson, you can refer to the documentation on their respective websites.\nThe pandas module is essential for data manipulation and analysis, while geopandas extends its functionality to handle geospatial data. matplotlib is used for creating static, animated, and interactive visualizations. numpy provides support for large, multi-dimensional arrays and matrices, along with a collection of mathematical functions to operate on these arrays.\nThe requests module allows you to send HTTP requests and interact with APIs easily. contextily adds basemaps to your plots, enhancing the visual context of your geospatial data. pygris simplifies the process of working with US Census Bureau TIGER/Line shapefiles.\nrasterio and xarray are used for working with geospatial raster data. rasterio reads and writes geospatial raster datasets, while xarray introduces labels in the form of dimensions, coordinates, and attributes on top of raw NumPy-like arrays, making it easier to work with labeled multi-dimensional arrays.\nshapely is used for manipulation and analysis of geometric objects. scipy provides additional tools for scientific computing, including statistical functions and interpolation methods. rioxarray combines the functionality of rasterio and xarray for easier handling of geospatial raster data.\npysal is a library for spatial analysis, providing tools for exploratory spatial data analysis. splot is a visualization module that works with pysal to create statistical plots for spatial analysis.\nMake sure these modules are installed before you begin working with the code in this document.\n\n\n\nICIS Air\nICIS-AIR (Integrated Compliance Information System for Air) is a comprehensive database maintained by the U.S. Environmental Protection Agency (EPA) that focuses specifically on air quality compliance and enforcement data. It tracks information related to stationary sources of air pollution, including their compliance with various Clean Air Act regulations, permit data, and enforcement actions. While ICIS-AIR and the Toxic Release Inventory (TRI) are separate systems, they have significant overlap in their coverage of industrial facilities and air emissions. Many facilities that report to TRI also have data in ICIS-AIR, providing complementary information.\nWhere TRI focuses on the quantities of specific toxic chemicals released into the air, ICIS-AIR offers a broader picture of a facility’s overall air quality compliance status, including non-toxic pollutants regulated under the Clean Air Act. Together, these systems provide a more comprehensive view of industrial air pollution sources, enabling researchers, regulators, and the public to assess both the types and quantities of air pollutants emitted (from TRI) and the regulatory compliance status of the emitting facilities (from ICIS-AIR).\n\nData Processing\n\nDefining Our Study Area\nNext we’ll query the API for ICIS-AIR regulated facilities in the greater Detroit area, but first we need to create a spatial object that defines our study area that we can use throughout this analysis. The U.S. Census Bureau defines the Detroit, MI Metropolitan Statistical Area (MSA) as including 6 counties (Wayne, Macomb, Oakland, Lapeer, Livingston, and St. Clair), but for this lesson we will focus on the core 3 counties (Wayne, Macomb, and Oakland); both population and air emissions related facilities are much more sparse in the outer counties.\nWe can us pygris to get vector boundaries for the counties and dissolve them into a single boundary we can you for cropping data and restricting API searches.\n\nimport geopandas as gpd\nimport pandas as pd\nimport pygris\nfrom shapely.geometry import box\n\n\ncounties = ['Wayne', 'Oakland', 'Macomb']\n\n# Fetch Detroit metro area counties using pygris\nmetro_counties = pygris.counties(state=\"MI\", year=2022)\ndetroit_metro = metro_counties[metro_counties['NAME'].isin(counties)]\n\n# Dissolve the counties into a single polygon\ndetroit_metro = detroit_metro.dissolve(by='STATEFP')\n\n# Convert to GeoDataFrame\ndetroit_metro = gpd.GeoDataFrame(detroit_metro, geometry='geometry', crs='EPSG:4269')\n\n# Get the bounding box\nbbox = detroit_metro.total_bounds\n\n# Create the bounding box as a polygon\nbbox_polygon = gpd.GeoDataFrame(\n    geometry=[box(*bbox)],\n    crs=detroit_metro.crs\n)\n\nUsing FIPS code '26' for input 'MI'\n\n\nLet’s verify this by overlaying it on a basemap.\n\nimport matplotlib.pyplot as plt\nimport contextily as ctx\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(7, 7))\n\n# Reproject data to Web Mercator to match the basemap\ndetroit_metro_bm = detroit_metro.to_crs(epsg=3857)\nbbox_polygon_bm = bbox_polygon.to_crs(epsg=3857)\n\n# Plot the metro area and bounding box\ndetroit_metro_bm.plot(ax=ax, color='lightblue', edgecolor='darkblue', alpha=0.3)\nbbox_polygon_bm.boundary.plot(ax=ax, color='grey', linewidth=2)\n\n# Add the basemap\nctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent of the map to the bounding box\nax.set_xlim(bbox_polygon_bm.total_bounds[0], bbox_polygon_bm.total_bounds[2])\nax.set_ylim(bbox_polygon_bm.total_bounds[1], bbox_polygon_bm.total_bounds[3])\n\n# Remove axes\nax.set_axis_off()\n\nplt.title(\"Detroit Metro Study Area\", fontsize=16)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nThis looks correct, and we’ll use this boundary object repeatedly throughout our analysis.\n\n\n\nQuerying the API\nThe EPA’s Enforcement and Compliance History Online (ECHO) website serves as a comprehensive portal for environmental compliance and enforcement data. It includes the ECHO Data Service, which provides programmatic access to EPA data through RESTful APIs. Among these is the ICIS-AIR API, which specifically offers access to air quality compliance and enforcement data. This API allows users to retrieve detailed information about stationary sources of air pollution, including facility details, permit data, emissions reports, and compliance status.\nThe ECHO API requires that users follow a multi-step workflow to acquire data via the Facility Air API:\n\nUse get_facilities to validate parameters, get summary statistics, and obtain a query_id (QID), valid for about 30 minutes.\nUse get_qid with the obtained QID to paginate through facility results.\nUse get_map with the QID to visualize and navigate facility locations.\nUse get_download with the QID to generate a CSV file of facility information.\n\nThe get_facility_info endpoint operates independently, returning either clustered summary statistics or an array of individual facilities. This API structure allows for efficient querying, visualization, and extraction of air quality compliance data, making it a valuable resource for environmental analysis and research.\nWe’ll begin by querying this database for just Michigan facilities in the workflow detailed above. From there we’ll subset with our list of counties.\nWe start with the base url for the ECHO API and our parameter list.\n\n# Base URL for ECHO ICIS-AIR API\nbase_url = \"https://echodata.epa.gov/echo/air_rest_services\"\n\n# Parameters for the initial API call\nparams = {\n    \"output\": \"JSON\",\n    \"p_st\": \"MI\"\n}\n\n\n\n\n\n\n\n\n\nData Science Review\n\n\n\nAn Application Programming Interface (API) is a set of protocols, tools, and definitions that enable different software applications to communicate with each other. It acts as an intermediary, allowing one application to request specific data or actions from another application or service without needing access to its entire codebase. APIs define the methods and data formats that applications can use to request and exchange information, typically through specific endpoints (URLs) that accept requests and return responses in standardized formats like JSON. They are crucial for integrating external services, accessing databases, and enabling communication between different parts of larger open science software systems.\n\n\nNow we define 2 functions that will carry out the first 2 steps; 1) identifying the facilities in our search and 2) retrieve the facility data.\n\nimport requests\n\n# Define the function to query the API for the facilities of interest\ndef get_facilities():\n    response = requests.get(f\"{base_url}.get_facilities\", params=params)\n    if response.status_code == 200:\n        data = response.json()\n        if 'Results' in data:\n            qid = data['Results']['QueryID']\n            print(f\"Query ID: {qid}\")\n            print(f\"Total Facilities: {data['Results']['QueryRows']}\")\n            return qid\n    print(\"Failed to get facilities and QID\")\n    return None\n\n# Define the function to retrieve the relevant data from the facilities of interest\ndef get_facility_data(qid):\n    all_facilities = []\n    page = 1\n    while True:\n        params = {\"qid\": qid, \"pageno\": page, \"output\": \"JSON\"}\n        response = requests.get(f\"{base_url}.get_qid\", params=params)\n        if response.status_code == 200:\n            data = response.json()\n            if 'Results' in data and 'Facilities' in data['Results']:\n                facilities = data['Results']['Facilities']\n                if not facilities:  # No more facilities to retrieve\n                    break\n                all_facilities.extend(facilities)\n                print(f\"Retrieved page {page}\")\n                page += 1\n            else:\n                break\n        else:\n            print(f\"Failed to retrieve page {page}\")\n            break\n    return all_facilities\n\nNow that we’ve defined the functions we can make a request to the API with our Detroit metro counties.\n\n# Step 1: Get the Query ID\nqid = get_facilities()\n\nif qid:\n    # Step 2: Use get_qid to retrieve all facility data\n    print(\"Retrieving facility data...\")\n    facilities = get_facility_data(qid)\n    \n    # Convert to DataFrame\n    df_icis_air = pd.DataFrame(facilities)\n    \n    print(f\"\\nSuccessfully retrieved {len(df_icis_air)} ICIS-AIR facilities for Michigan\")\n    print(\"\\nColumns in the dataset:\")\n    print(df_icis_air.columns)\n    \nelse:\n    print(\"Failed to retrieve facility data\")\n\nQuery ID: 113\nTotal Facilities: 3395\nRetrieving facility data...\nRetrieved page 1\n\nSuccessfully retrieved 3395 ICIS-AIR facilities for Michigan\n\nColumns in the dataset:\nIndex(['AIRName', 'SourceID', 'AIRStreet', 'AIRCity', 'AIRState',\n       'LocalControlRegionCode', 'AIRZip', 'RegistryID', 'AIRCounty',\n       'AIREPARegion', 'FacFederalAgencyCode', 'FacFederalAgencyName',\n       'FacDerivedHuc', 'FacFIPSCode', 'FacIndianCntryFlg',\n       'AIRIndianCntryFlg', 'FacIndianSpatialFlg', 'FacDerivedTribes',\n       'FacUsMexBorderFlg', 'FacSICCodes', 'AIRNAICS', 'FacLat', 'FacLong',\n       'AIRPrograms', 'AIRMacts', 'AIRStatus', 'AIRUniverse',\n       'AIRClassification', 'AIRCmsCategoryCode', 'AIRCmsCategoryDesc',\n       'FacDerivedWBD', 'FacDerivedWBDName', 'ChesapeakeBayFlag', 'AIRIDs',\n       'CWAIDs', 'RCRAIDs', 'RmpIDs', 'SDWAIDs', 'TRIIDs', 'GHGIDs', 'EisIDs',\n       'CamdIDs', 'AIRComplStatus', 'AIRHpvStatus', 'AIRMnthsWithHpv',\n       'AIRQtrsWithHpv', 'AIRQtrsWithViol', 'AIRPollRecentViol',\n       'AIRRecentViolCnt', 'AIRLastViolDate', 'AIREvalCnt', 'AIRDaysLastEval',\n       'AIRLastEvalDate', 'AIRLastEvalDateEPA', 'AIRLastEvalDateState',\n       'AIRFceCnt', 'AIRDaysLastFce', 'AIRLastFceDate', 'AIRLastFceDateEPA',\n       'AIRLastFceDateState'],\n      dtype='object')\n\n\nThere are over three thousand facilities in the ICIS-AIR Michigan dataset. Here are the descriptions for some key columns.\n\n\nKey Columns in the ICIS-AIR ECHO API Dataset\n\nAIRName: The name of the facility\nSourceID: A unique identifier for the air pollution source\nAIRStreet, AIRCity, AIRState, AIRZip: Address components of the facility\nRegistryID: A unique identifier for the facility in the EPA’s registry\nAIRCounty: The county where the facility is located\nAIREPARegion: The EPA region responsible for the facility\nAIRNAICS: North American Industry Classification System code(s) for the facility\nFacLat, FacLong: Latitude and longitude coordinates of the facility\nAIRPrograms: Air quality programs applicable to the facility\nAIRStatus: Current operational status of the facility\nAIRUniverse: Categorization of the facility within air quality regulation\nAIRComplStatus: Current compliance status under the Clean Air Act\nAIRHpvStatus: High Priority Violator status\nAIRQtrsWithViol: Number of quarters with violations\nAIRLastViolDate: Date of the most recent violation\nAIREvalCnt: Count of evaluations conducted\nAIRLastEvalDate: Date of the most recent evaluation\nAIRFceCnt: Count of Full Compliance Evaluations\nAIRLastFceDate: Date of the last Full Compliance Evaluation\n\nThese columns provide information about each facility’s location, operational characteristics, compliance history, and regulatory oversight under the Clean Air Act. It includes information on violations, evaluations, and compliance status that assess a facility’s environmental performance and regulatory compliance.\nWe can check some basic information like how many facilities are in Detroit metro and the breakdown by our 3 counties.\n\n# Subset the dataframe to include only the Detroit metro counties\nicis_air_detroit = df_icis_air[df_icis_air['AIRCounty'].isin(counties)]\n\n# Print information about the subset\nprint(f\"Total ICIS-AIR facilities in Michigan: {len(df_icis_air)}\")\nprint(f\"ICIS-AIR facilities in Detroit metro area: {len(icis_air_detroit)}\")\n\n# Display the count of facilities in each metro county\nprint(\"\\nFacilities per county:\")\nprint(icis_air_detroit['AIRCounty'].value_counts())\n\nTotal ICIS-AIR facilities in Michigan: 3395\nICIS-AIR facilities in Detroit metro area: 903\n\nFacilities per county:\nAIRCounty\nWayne      431\nOakland    272\nMacomb     200\nName: count, dtype: int64\n\n\nNext we should check for facilities with missing latitude or longitude coordinates.\n\n# Count records with missing coordinate values\nmissing_coords = icis_air_detroit[(icis_air_detroit['FacLat'].isnull()) | (icis_air_detroit['FacLong'].isnull())]\nprint(f\"Number of ICIS-AIR records with missing coordinates: {len(missing_coords)}\")\n\n# Remove records with missing coordinates\nicis_air_detroit = icis_air_detroit.dropna(subset=['FacLat', 'FacLong'])\n\nNumber of ICIS-AIR records with missing coordinates: 0\n\n\nNo missing records! That’s great. As you’ll find out later, you won’t always be so lucky.\nNow we can create a spatial object, reproject it so it matches the basemap of Detroit, and make a map showing the location of all the ICIS-AIR facilities in Detroit metro.\n\n# Create a GeoDataFrame for ICIS-AIR facilities\ngdf_icis_air = gpd.GeoDataFrame(\n    icis_air_detroit, \n    geometry=gpd.points_from_xy(icis_air_detroit.FacLong, icis_air_detroit.FacLat),\n    crs=\"EPSG:4326\"\n)\n\n# Reproject ICIS-AIR data to Web Mercator so it matches the basemap\ngdf_icis_air_bm = gdf_icis_air.to_crs(epsg=3857)\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(7, 7))\n\n# Plot the metro area and bounding box (reusing objects from earlier)\ndetroit_metro_bm.plot(ax=ax, facecolor='none', edgecolor='blue', linewidth=2)\nbbox_polygon_bm.boundary.plot(ax=ax, color='#315c86', linewidth=3)\n\n# Plot ICIS-AIR facilities\ngdf_icis_air_bm.plot(ax=ax, color='cyan', markersize=50, alpha=0.5, label='ICIS-AIR Facilities', edgecolor = \"grey\")\n\n# Add the basemap\nctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent of the map to the bounding box\nax.set_xlim(bbox_polygon_bm.total_bounds[0], bbox_polygon_bm.total_bounds[2])\nax.set_ylim(bbox_polygon_bm.total_bounds[1], bbox_polygon_bm.total_bounds[3])\n\n# Remove axes\nax.set_axis_off()\n\n# Add legend\nax.legend()\n\nplt.title(\"Detroit Metro Area ICIS-AIR Facilities\", fontsize=16)\nplt.tight_layout()\nplt.show()\n\nprint(f\"Number of ICIS-AIR facilities plotted: {len(gdf_icis_air)}\")\n\n\n\n\n\n\n\n\nNumber of ICIS-AIR facilities plotted: 903\n\n\nThese are distributed along business and industrial sectors as expected, but we can’t infer much else from this map.\nWhich regulated facilities have been in violation status? We can plot all the facilities with at least one violation during a reporting quarter and use graduated symbols that reflect the total number of quarters with violations. This information is in the AIRQtrsWithViol column.\n\n# Convert to numeric, replacing non-numeric values with NaN\ngdf_icis_air_bm['AIRQtrsWithViol'] = pd.to_numeric(gdf_icis_air_bm['AIRQtrsWithViol'], errors='coerce')\n\n# subset the dataset for those with violations\ngdf_icis_air_violators = gdf_icis_air_bm = gdf_icis_air_bm[gdf_icis_air_bm['AIRQtrsWithViol'] &gt; 0]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(7, 7))\n\n# Plot the metro area and bounding box (reusing objects from earlier)\ndetroit_metro_bm.plot(ax=ax, facecolor='none', edgecolor='blue', linewidth=2)\nbbox_polygon_bm.boundary.plot(ax=ax, color='#315c86', linewidth=3)\n\n# Plot TRI facilities with graduated symbols based on air releases\nscatter = ax.scatter(gdf_icis_air_violators.geometry.x,\n                     gdf_icis_air_violators.geometry.y, \n                     s=gdf_icis_air_violators['AIRQtrsWithViol']*10,  # Adjust the multiplier as needed\n                     c='orangered', \n                     edgecolor='yellow', \n                     linewidth=1, \n                     alpha=0.7)\n\n# Add the basemap\nctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent of the map to the bounding box\nax.set_xlim(bbox_polygon_bm.total_bounds[0], bbox_polygon_bm.total_bounds[2])\nax.set_ylim(bbox_polygon_bm.total_bounds[1], bbox_polygon_bm.total_bounds[3])\n\n# Remove axes\nax.set_axis_off()\n\n# Add legend\nax.legend()\n\nplt.title(\"Detroit Metro Area ICIS-AIR Facilities w/ Violations\", fontsize=16)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nWe can also create a table showing which businesses have been in violation statues, their name, address, and the date of their most recent violation using the tabulate module.\n\nfrom tabulate import tabulate\n\ngdf_icis_air_violators = gdf_icis_air_bm = gdf_icis_air_bm[gdf_icis_air_bm['AIRQtrsWithViol'] &gt;= 10]\n\n# List the columns we want to use\ntable_columns = ['AIRName', 'AIRStreet', 'AIRCity', 'AIRQtrsWithViol', 'AIRLastViolDate']\n\n# Create a new DataFrame with only the columns we want\ntable_data = gdf_icis_air_violators[table_columns].copy()\n\n# Ensure AIRLastViolDate is in datetime format\ntable_data['AIRLastViolDate'] = pd.to_datetime(table_data['AIRLastViolDate'])\n\n# Sort the DataFrame by AIRLastViolDate in descending order\ntable_data = table_data.sort_values('AIRLastViolDate', ascending=False)\n\n# Create a dictionary to map old column names to pretty column names\npretty_names = {\n    'AIRName': 'Name',\n    'AIRStreet': 'Street',\n    'AIRCity': 'City',\n    'AIRQtrsWithViol': 'Violations',\n    'AIRLastViolDate': 'Violation Date'\n}\n\n# Rename the columns\ntable_data.rename(columns=pretty_names, inplace=True)\n\n# Format the 'Violation Date' column to a specific date format (optional)\ntable_data['Violation Date'] = table_data['Violation Date'].dt.strftime('%Y-%m-%d')\n\n# Create the table\ntable = tabulate(table_data, headers='keys', tablefmt='html', showindex=False)\ntable \n\n\n\n\nName\nStreet\nCity\nViolations\nViolation Date\n\n\n\n\nEES COKE BATTERY L.L.C.\n1400 ZUG ISLAND ROAD\nRIVER ROUGE\n12\n2024-04-23\n\n\nROSATI SPECIALTIES\n24200 CAPITAL BLVD.\nCLINTON TWP\n12\n2024-03-21\n\n\nCARMEUSE LIME INC, RIVER ROUGE OPERATION\n25 MARION AVE\nRIVER ROUGE\n12\n2023-08-17\n\n\nBASF CORPORATION - CHEMICAL PLANTS\n1609 BIDDLE AVE\nWYANDOTTE\n12\n2023-03-24\n\n\nMARATHON PETROLEUM COMPANY LP\n1001 S OAKWOOD\nDETROIT\n12\n2023-03-15\n\n\nFCA US LLC - DETROIT ASSEMBLY COMPLEX\n2101 CONNER AVE\nDETROIT\n12\n2023-01-25\n\n\nU S STEEL GREAT LAKES WORKS\n1 QUALITY DR\nECORSE\n12\n2022-11-07\n\n\nFCA US LLC WARREN TRUCK ASSEMBLY PLANT\n21500 MOUND ROAD\nWARREN\n12\n2022-10-21\n\n\nNYLOK LLC\n15260 HALLMARK COURT\nMACOMB\n12\n2022-08-29\n\n\nAJAX METAL PROCESSING INC.\n4651 BELLEVUE AVE\nDETROIT\n10\n2022-06-07\n\n\nSTERLING ENGINE HOLDINGS LLC\n54420 PONTIAC TRAIL\nMILFORD\n12\n2021-06-10\n\n\nDETROIT RENEWABLE POWER, LLC\n5700 RUSSELL ST\nDETROIT\n12\n2019-08-29\n\n\nJVISFH, LLC\n23944 FREEWAY PARK DRIVE\nFARMINGTN HLS\n12\n2019-03-22\n\n\nLEAR CORPORATION DBA EAGLE OTTAWA\n2930 WEST AUBURN RD\nROCHESTER HLS\n11\n2014-11-10\n\n\nBASF CORPORATION - PLASTIC PLANTS\n1609 BIDDLE AVE.\nWYANDOTTE\n12\n2014-06-24\n\n\nWYANDOTTE DEPT MUNI POWER PLANT\n2555 VAN ALSTYNE\nWYANDOTTE\n12\n2014-04-21\n\n\nPOWER SOLUTIONS INTERNATIONAL\n32505 INDUSTRIAL DRIVE\nMADISON HTS\n12\n2013-12-09\n\n\nHENRY FORD WEST BLOOMFIELD HOSPITAL\n6777 WEST MAPLE ROAD\nW BLOOMFIELD\n12\n2012-05-03\n\n\nHD INDUSTRIES\n19455 GLENDALE\nDETROIT\n12\n2012-04-18\n\n\n\n\n\nICIS-AIR is a powerfule tool for communites and policy-makers to identify regulated facilities and their compliance status, but the dataset does have limitations. Next, we’ll take a look at facilities required to report to the Toxic Release Inventory (TRI).\n\n\n\n\n\n\nKnowledge Check\n\n\n\nWhich of the following best describes the ICIS-AIR database?\n\nA database of air quality measurements from monitoring stations\nA comprehensive database of air quality compliance and enforcement data\nA public health database tracking respiratory illnesses\nA database of weather patterns affecting air quality\n\n\n\n\n\n\nToxic Release Inventory\nThe Toxic Release Inventory (TRI) is a crucial resource in understanding and addressing air quality issues in the United States. Established under the Emergency Planning and Community Right-to-Know Act of 1986, the TRI is a publicly accessible database maintained by the Environmental Protection Agency (EPA). It requires certain industrial facilities to report annually on their releases of toxic chemicals into the environment, including air emissions. The TRI provides valuable data on over 770 chemicals and chemical categories, offering insights into the types and quantities of pollutants released into the air by various industries. This information is vital to researchers, policymakers, and community advocates in assessing local air quality, identifying potential health risks, and developing targeted strategies to reduce toxic air emissions. By making this data publicly available, the TRI plays an important role in promoting transparency and supporting environmental justice initiatives focused on improving air quality in communities across the nation.\n\n\n\n\n\n\nData Review\n\n\n\nThe Toxics Release Inventory (TRI) and the Integrated Compliance Information System for Air (ICIS-AIR) are two important but distinct environmental reporting systems maintained by the U.S. Environmental Protection Agency (EPA). They have several key differences:\n\nRegulatory Basis\n\nTRI: Established under the Emergency Planning and Community Right-to-Know Act (EPCRA) of 1986\nICIS-AIR: Part of the Clean Air Act (CAA) compliance and enforcement program\n\nFocus\n\nTRI: Tracks the management of certain toxic chemicals that may pose a threat to human health and the environment\nICIS-AIR: Focuses specifically on air quality and emissions from facilities regulated under the Clean Air Act\n\nReported Information\n\nTRI: Facilities report on releases, waste management, and pollution prevention activities for specific toxic chemicals\nICIS-AIR: Tracks emissions data, compliance status, and enforcement actions related to air quality regulations\n\nFacility Coverage\n\nTRI: Covers facilities in specific industries that manufacture, process, or use TRI-listed chemicals above certain thresholds\nICIS-AIR: Includes a broader range of facilities that emit air pollutants, regardless of the specific chemicals involved\n\nReporting Thresholds\n\nTRI: Has specific chemical thresholds that trigger reporting requirements\nICIS-AIR: Generally doesn’t have chemical-specific thresholds; requirements are based on overall emissions and facility type\n\nPublic Accessibility\n\nTRI: Designed with a strong focus on public right-to-know, with data easily accessible to the public\nICIS-AIR: While public, it’s primarily designed for regulatory and enforcement purposes\n\nData Frequency\n\nTRI: Annual reporting is required for covered facilities\nICIS-AIR: May involve more frequent reporting, depending on permit requirements and compliance status\n\nScope of Pollutants\n\nTRI: Focuses on a specific list of toxic chemicals and chemical categories\nICIS-AIR: Covers a wider range of air pollutants, including criteria air pollutants and hazardous air pollutants\n\nUse in Environmental Management\n\nTRI: Often used for assessing long-term trends in toxic chemical releases and waste management practices\nICIS-AIR: More commonly used for day-to-day air quality management and enforcement activities\n\nGeographic Coverage\n\nTRI: Nationwide program with consistent reporting across states\nICIS-AIR: While national, implementation can vary more by state or local air quality management district\n\n\n\n\n\nEnvirofacts API\nEnviroFacts is a comprehensive online database and information system maintained by the U.S. Environmental Protection Agency (EPA). It serves as a centralized hub for accessing a wide range of environmental data collected by the EPA and other federal agencies. EnviroFacts integrates information from multiple EPA databases, covering various aspects of environmental health, including air quality, water quality, hazardous waste, and toxic releases. One of the key components of EnviroFacts is the Toxic Release Inventory (TRI) data. Through EnviroFacts, users can easily access and query TRI information, allowing them to investigate toxic chemical releases and waste management activities in their local areas. The integration of TRI data within the broader EnviroFacts system enables researchers, policymakers, and community members to contextualize toxic release information alongside other environmental indicators.\nEnvirofacts is available as a web based search and data platform and also as a programmatic API. The web platform is a great way to familiarize yourself with the available datasets and create simple downloads, however, for analytical purposes we recommend learning to navigate their API so you can create repeatable and reliable analysis.\n\n\n\n\n\n\nEnvironmental Justice In the News\n\n\n\nThe Michigan Department of Environment, Great Lakes and Energy (EGLE) has settled a civil rights complaint regarding a hazardous waste facility in Detroit. The complaint, filed in 2020 by environmental groups and local residents, challenged the renewal and expansion of U.S. Ecology North’s license, arguing it was unjust to increase hazardous waste storage in a predominantly low-income and minority neighborhood. As part of the settlement, EGLE will now consider environmental justice concerns in future licensing decisions for hazardous waste facilities.\nThe agreement, described as “groundbreaking” by the Sierra Club, introduces several new measures. EGLE will conduct environmental justice and cumulative impact analyses for future licensing decisions, potentially denying licenses that would have an unlawful impact on human health and the environment. The settlement also includes provisions for improved community engagement, such as better translation services, public input processes, and the installation of air monitors around U.S. Ecology North. Additionally, the state will work with local residents to conduct a community health assessment. While some details remain to be clarified, environmental advocates view this as a significant step towards advancing environmental justice in Michigan.\n\n\n\n\nQuerying the API\nWe’ll continue to use the Detroit metro boundary we created earlier. We assigned them the names detroit_metro and detroit_metro_bm (projected to mercator to match basemaps for plotting).\n\n# Print the bounding box coordinates\nprint(\"Bounding Box:\")\nprint(f\"Minimum X (Longitude): {bbox[0]}\")\nprint(f\"Minimum Y (Latitude): {bbox[1]}\")\nprint(f\"Maximum X (Longitude): {bbox[2]}\")\nprint(f\"Maximum Y (Latitude): {bbox[3]}\")\n\nBounding Box:\nMinimum X (Longitude): -83.689438\nMinimum Y (Latitude): 42.02793\nMaximum X (Longitude): -82.705966\nMaximum Y (Latitude): 42.897541\n\n\nNow we’ll create and empty list to store the TRI data, loop through each county making an API query, and place the retrieved data in the empty container.\n\n# Fetch TRI facility data from EPA API for each county\ntri_data = []\n\n# Loop through each county to make a separate API inquiry (was having trouble attempting all at once)\nfor county in counties:\n    api_url = f\"https://data.epa.gov/efservice/tri_facility/state_abbr/MI/county_name/{county}/JSON\"\n    response = requests.get(api_url)\n    # Is our response good\n    if response.status_code == 200:\n        county_data = response.json()\n        # Add the county to the list\n        tri_data.extend(county_data)\n    else:\n        print(f\"Failed to fetch data for {county} County. Status code: {response.status_code}\")\n\n\n\nProcessing the Data\nThe TRI data comes in json format. They can be a little confusing to interpret, becauce each record (traditionally a row in a table) is viewed with columns structured vertically. Let’s look at the first record.\n\ntri_data[1]\n\n{'tri_facility_id': '48007GRWGR3155W',\n 'facility_name': 'PPG GROW DETROIT',\n 'street_address': '14000 STANSBURY',\n 'city_name': 'DETROIT',\n 'county_name': 'WAYNE',\n 'state_county_fips_code': '26163',\n 'state_abbr': 'MI',\n 'zip_code': '48227',\n 'region': '5',\n 'fac_closed_ind': '0',\n 'mail_name': 'PPG INDS.',\n 'mail_street_address': '1330 PIEDMONT ATTN:  RICH MCCURDY',\n 'mail_city': 'TROY',\n 'mail_state_abbr': 'MI',\n 'mail_province': None,\n 'mail_country': None,\n 'mail_zip_code': '48083',\n 'asgn_federal_ind': 'C',\n 'asgn_agency': None,\n 'frs_id': None,\n 'parent_co_db_num': '001344803',\n 'parent_co_name': 'PPG INDS INC',\n 'fac_latitude': 422146,\n 'fac_longitude': 831255,\n 'pref_latitude': 42.3903,\n 'pref_longitude': 83.182,\n 'pref_accuracy': 150,\n 'pref_collect_meth': 'A1',\n 'pref_desc_category': 'PG',\n 'pref_horizontal_datum': '1',\n 'pref_source_scale': 'J',\n 'pref_qa_code': '1000',\n 'asgn_partial_ind': '0',\n 'asgn_public_contact': None,\n 'asgn_public_phone': None,\n 'asgn_public_contact_email': None,\n 'bia_code': None,\n 'standardized_parent_company': None,\n 'asgn_public_phone_ext': None,\n 'epa_registry_id': '110041981807',\n 'asgn_technical_contact': None,\n 'asgn_technical_phone': None,\n 'asgn_technical_phone_ext': None,\n 'mail': None,\n 'asgn_technical_contact_email': None,\n 'foreign_parent_co_name': None,\n 'foreign_parent_co_db_num': None,\n 'standardized_foreign_parent_company': None}\n\n\nThis record shows all the information for PPG GROW DETROIT with columns and values listed side-by-side (‘city_name’: ‘DETROIT’). This may seem difficult to deal with, but most programming languages have tools to easily parse json data into traditional tables. pd.DataFrame does it automatically when you attempt to create a pandas data frame.\n\n# Convert TRI data to a DataFrame\ntri_df = pd.DataFrame(tri_data)\n\nprint(f\"Number of facilities fetched: {len(tri_df)}\")\n\n# Check the first few rows (too large to print in this document)\n# tri_df.head\n\nNumber of facilities fetched: 791\n\n\nChecking the first few rows–everything looks as it should. We want to geocode the facility locations into a point layer using the latitude and longitude values. Therefore, we should start by making sure all the facilities have latitude and longitude values.\nWe’ll check and remove those without.\n\n# Create a copy of the dataframe to avoid SettingWithCopyWarning\ntri_df_clean = tri_df.copy()\n\n# Remove facilities with empty latitude or longitude values\ntri_df_clean = tri_df_clean.dropna(subset=['pref_latitude', 'pref_longitude'])\n\nprint(f\"Number of facilities after removing empty coordinates: {len(tri_df_clean)}\")\n\n# Convert latitude and longitude to numeric type\ntri_df_clean['pref_latitude'] = pd.to_numeric(tri_df_clean['pref_latitude'], errors='coerce')\ntri_df_clean['pref_longitude'] = pd.to_numeric(tri_df_clean['pref_longitude'], errors='coerce')\n\nNumber of facilities after removing empty coordinates: 478\n\n\nOuch! We lost roughly 300 records due to missing coordinates (789 vs. 478). If this were an important analysis for policy-making or scientific research we would take the time to geocode the listed addresses into lat/long coordinates, but for the purposes of this exercise we’ll move on.\nIn my personal investigations of this data, I noticed that some longitude coordinates were not negative, but had an absolute value (e.g. 83.25) that made sense for the Detroit metro area, therefore we will flip the sign on these records.\n\n# Function to correct longitude by making it negative if positive\ndef correct_longitude(lon):\n    if lon &gt; 0:\n        return -lon\n    return lon\n\n# Apply longitude correction\ntri_df_clean['pref_longitude'] = tri_df_clean['pref_longitude'].apply(correct_longitude)\n\nAdditionally, there are some records with wild longitudinal values that are not simply from a missing negative sign. We’ll identify these outliers using the interquantile range. Anything outside the range will be tosses. One of the downsides of the TRI database is that many aspects are provided directly by the facility (and therefore subject to errors). Again, if this were a more important analysis we would carefully explore all of these missing records and possible geocode using the address.\nToss the quartile outliers.\n\n# Calculate IQR for longitude\nQ1 = tri_df_clean['pref_longitude'].quantile(0.25)\nQ3 = tri_df_clean['pref_longitude'].quantile(0.75)\nIQR = Q3 - Q1\n\n# Define bounds for outliers\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n\nlower_bound, upper_bound\n\n# Remove outliers\ntri_df_clean = tri_df_clean[(tri_df_clean['pref_longitude'] &gt;= lower_bound) & \n                            (tri_df_clean['pref_longitude'] &lt;= upper_bound)]\n\nprint(f\"Number of facilities after removing longitude outliers: {len(tri_df_clean)}\")\n\nNumber of facilities after removing longitude outliers: 473\n\n\nThankfully we only lost 2 more records from outlier.\n\n\nVisualizing the Data\nThe data has been cleaned up a bit so now lets create a spatial point object from the data with geopandas and use matplotlib to plot the values on top of a basemap of Detroit we’ll acquire using contextily and our original Wayne, Macomb, and Oakland counties boundary.\n\n# Create a GeoDataFrame from the cleaned TRI data\ndetroit_tri = gpd.GeoDataFrame(\n    tri_df_clean, \n    geometry=gpd.points_from_xy(tri_df_clean.pref_longitude, tri_df_clean.pref_latitude),\n    crs=\"EPSG:4326\"\n)\n\n# Reproject data to Web Mercator for contextily\n# detroit_metro = detroit_metro.to_crs(epsg=3857)\n# bbox_polygon = bbox_polygon.to_crs(epsg=3857)\ndetroit_tri = detroit_tri.to_crs(epsg=3857)\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(7, 7))\n\n# Plot the metro area and bounding box (reusing objects from earlier)\ndetroit_metro_bm.plot(ax=ax, facecolor='none', edgecolor='blue', linewidth=2)\nbbox_polygon_bm.boundary.plot(ax=ax, color='#315c86', linewidth=3)\n\n# Plot TRI facilities (reusing the detroit_tri object from earlier)\ndetroit_tri.plot(ax=ax, color='purple', edgecolor='grey', markersize=50, alpha=0.5, label='TRI Facilities')\n# Plot ICIS-AIR facilities\ngdf_icis_air_bm.plot(ax=ax, color='cyan', edgecolor='grey', markersize=50, alpha=0.5, label='ICIS-AIR Facilities')\n\n# Add the basemap\nctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent of the map to the bounding box\nax.set_xlim(bbox_polygon_bm.total_bounds[0], bbox_polygon_bm.total_bounds[2])\nax.set_ylim(bbox_polygon_bm.total_bounds[1], bbox_polygon_bm.total_bounds[3])\n\n# Remove axes\nax.set_axis_off()\n\n# Add legend\nax.legend()\n\nplt.title(\"Detroit Metro Area TRI and ICIS-AIR Facilities\", fontsize=16)\nplt.tight_layout()\nplt.show()\n\nprint(f\"Number of TRI facilities plotted: {len(detroit_tri)}\")\nprint(f\"Number of ICIS-AIR facilities plotted: {len(gdf_icis_air)}\")\n\n\n\n\n\n\n\n\nNumber of TRI facilities plotted: 473\nNumber of ICIS-AIR facilities plotted: 903\n\n\nWe can see that there are far fewer facilities being tracked in TRI compared to ICIS-AIR. While some of this can be attributed to the records we tossed after checking for valid geographic coordinates and outliers, but generally speaking ICIS-AIR will contain far more as it tracks every facility regulated by the Clean Air Act as opposed to only those that are part of TRI.\nYou may have also noticed that this dataset does not contain any actually pollution data; only facility information for those that are regulated by TRI.\nTRI is made up of numerous tables containing a wealth of information regarding the facilities themselves and all the regulated chemicals that are handled at each site. The TRI_FACILITY table we requested is the starter table used in most of the examples in the Envirofacts API documentation, however, it does not contain any chemical release data.\nNavigating the TRI Envirofacts interface can be overwhelming at times. Multiple tables can be queried with a single URL, however, for a proper join to be carried out both tables must contain at least 1 column. In most cases this can be accomplished using TRI_FACILITY_ID. That said, air pollution release data (column name AIR_TOTAL_RELEASE) is only found in the TRI_FORM_R table, which does not contain the FACILITY_ID column.\nYou can querry the V_TRI_FORM_R_EZ using the API even though it’s not a documented table listed in the API website. This form contains facility information and AIR_TOTAL_RELEASE reporting, but it only goes until 2021. To get the most recent data (2023) you would have to manually download the individual tables with separate calls perform the joins, or use the custom form search web portal. We’ll demonstrate a quick API call for the V_TRI_FORM_R_EZ, but move forward with the most recent data available in the custom form search web portal.\n\n\n\n\n\n\nKnowledge Check\n\n\n\nWhat is the primary purpose of the Toxic Release Inventory (TRI)?\n\nTo track emissions of greenhouse gases\nTo monitor compliance with the Clean Air Act\nTo provide data on toxic chemical releases from industrial facilities\nTo record air quality index values for major cities\n\n\n\n\n\n\nToxic Release Inventory: Form R\nWe can make the query to Envirofacts. Let’s breakdown the call.\n\n# URL of the CSV file\nurl = \"https://data.epa.gov/efservice/V_TRI_FORM_R_EZ/REPORTING_YEAR/2021/AIR_TOTAL_RELEASE/&gt;/0/STATE_ABBR/MI/COUNTY_NAME/CONTAINING/WAYNE/CONTAINING/OAKLAND/CONTAINING/MACOMB/CSV\"\n\n\nBase url: https://data.epa.gov/efservice/\nThe table we’re requesting: V_TRI_FORM_R_EZ/\nFor just 2021: REPORTING_YEAR/2021/\nOnly facilities that report some air release: AIR_TOTAL_RELEASE/&gt;/0/\nJust Michigan: STATE_ABBR/MI/\nOur counties: COUNTY_NAME/CONTAINING/WAYNE/CONTAINING/OAKLAND/CONTAINING/MACOMB/\nWe want it as a csv: CSV\n\n\n# Read the CSV file directly with pandas\ntri_form_r = pd.read_csv(url)\nprint(f\"Successfully read CSV. Number of records: {len(tri_form_r)}\")\n\n# Display information about the dataset\nprint(\"\\nColumns in the dataset:\")\nprint(tri_form_r.columns)\n\nSuccessfully read CSV. Number of records: 413\n\nColumns in the dataset:\nIndex(['tri_facility_id', 'facility_name', 'street_address', 'city_name',\n       'county_name', 'state_county_fips_code', 'state_abbr', 'zip_code',\n       'region', 'fac_closed_ind',\n       ...\n       'additional_text_9_1', 'srs_id', 'media_type', 'prod_ratio_or_activity',\n       'industry_code', 'industry_description', 'source', 'method', 'adjusted',\n       'covered_naics'],\n      dtype='object', length=568)\n\n\nWe have roughly the same number of facilities as before, but this table has a lot of columns (568). We should make it more manageable.\n\nkeeps = [\n    'facility_name', 'street_address', 'city_name',\n    'reporting_year', 'air_total_release']\n\ntri_form_r = tri_form_r[keeps]\n\nThis works well but we can get more recent data that is already filtered using the web portal. The user selects location, years of interest, and columns of interests. The portal serves up your requested dataset in an Amazon S3 cloud storage. We can important the dataset directly from the address they provide you.\n\ntri_form_r = pd.read_csv(\"https://dmap-epa-enviro-prod-export.s3.amazonaws.com/396975438.CSV\")\n\n# Display information about the dataset\nprint(f\"Successfully read CSV. Number of records: {len(tri_form_r)}\")\nprint(\"\\nColumns in the dataset:\")\nprint(tri_form_r.columns)\n\nSuccessfully read CSV. Number of records: 994\n\nColumns in the dataset:\nIndex(['AIR_TOTAL_RELEASE', 'CHEM_NAME', 'FACILITY_NAME', 'LATITUDE',\n       'LONGITUDE', 'STREET_ADDRESS', 'TRI_FACILITY_ID'],\n      dtype='object')\n\n\nThis is a bit more manageable, but we have multiple records per facility because each chemical release has a separate record. This allows the user to investigate specific chemicals, but for the purposes of this exercise we will aggregate AIR_TOTAL_RELEASE for each facility.\n\n# Check how it looks (too large to print on the web)\n# tri_form_r.head\n\nLet’s aggregate it.\n\n# Sum across individual facilities\ntri_form_r = tri_form_r.groupby(['FACILITY_NAME', 'LATITUDE','LONGITUDE','STREET_ADDRESS'], as_index=False).agg({\n    'AIR_TOTAL_RELEASE': 'sum'\n})\n# How many records are there now\nprint(f\"Successfully read CSV. Number of records: {len(tri_form_r)}\")\n\nSuccessfully read CSV. Number of records: 211\n\n\nThere were only 211 unique listings in the 2023 data.\nAs before, we should check for valid coordinates and release data.\n\n# Assuming the latitude and longitude columns are named 'LATITUDE' and 'LONGITUDE'\n# Adjust these names if they're different in your CSV\nlat_col = 'LATITUDE'\nlon_col = 'LONGITUDE'\nrelease_col = 'AIR_TOTAL_RELEASE'  # Adjust this to the actual column name for air releases\n\n# Remove records with missing coordinates or air release data\ndf_tri_clean = tri_form_r.dropna(subset=[lat_col, lon_col, release_col])\n\nprint(f\"\\nNumber of records after removing missing data: {len(df_tri_clean)}\")\n\n\nNumber of records after removing missing data: 211\n\n\nThere were no missing coordinates are release data.\nNow we can create a spatial object with GeoPandas using the latitude and longitude coordinates in the table.\n\n# Create a GeoDataFrame\ngdf_tri_form_r = gpd.GeoDataFrame(\n    df_tri_clean, \n    geometry=gpd.points_from_xy(df_tri_clean[lon_col], df_tri_clean[lat_col]),\n    crs=\"EPSG:4326\"\n)\n\nLet’s check the distribution of the air release data. I suspect there will be outliers.\n\n# Create the histogram\nplt.figure(figsize=(8, 8))\nplt.hist(gdf_tri_form_r['AIR_TOTAL_RELEASE'], bins=10, edgecolor='black')\nplt.title('Histogram of Air Total Release Sum')\nplt.xlabel('Air Sum')\nplt.ylabel('Frequency')\nplt.grid(True, alpha=0.3)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\nLooks like there are outliers around 100,000 lbs and 400,000 lbs. Before we map the data, it would be a good idea to perform a log transformation of AIR_TOTAL_RELEASE to smooth out the visuals. You can’t take the log of negative or zero values, so we’ll use the log1p function, which adds 1 to every value before taking the log.\n\nimport numpy as np\n\n# Assuming 'result' is your DataFrame from earlier\ngdf_tri_form_r['LOG_AIR_RELEASE'] = np.log1p(gdf_tri_form_r['AIR_TOTAL_RELEASE'])\n\n# Create the histogram\nplt.figure(figsize=(8, 8))\nplt.hist(gdf_tri_form_r['LOG_AIR_RELEASE'], bins=10, edgecolor='black')\nplt.title('Histogram of the Log of Air Total Release Sum')\nplt.xlabel('Log of Air Sum')\nplt.ylabel('Frequency')\nplt.grid(True, alpha=0.3)\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\nThat looks much better.\nNow we can visualize the data, by overlaying the points on a basemap of Detroit while using graduated symbols to illustrate the amount of air releases for a given facility.\n\n# Reproject to Web Mercator to match the basemap\ngdf_tri_form_r_bm = gdf_tri_form_r.to_crs(epsg=3857)\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(7, 7))\n\n# Plot the metro area and bounding box (reusing objects from earlier)\ndetroit_metro_bm.plot(ax=ax, facecolor='none', edgecolor='blue', linewidth=2)\nbbox_polygon_bm.boundary.plot(ax=ax, color='#315c86', linewidth=2)\n\n# Plot TRI facilities with graduated symbols based on air releases\nscatter = ax.scatter(gdf_tri_form_r_bm.geometry.x, gdf_tri_form_r_bm.geometry.y, \n                     s=gdf_tri_form_r_bm['LOG_AIR_RELEASE']*20,  # Adjust the scaling factor as needed\n                     c='orangered',  # Static fill color\n                     edgecolor='yellow',  # Outline color\n                     linewidth=1,  # Adjust the outline width as needed\n                     alpha=0.7)\n\n# Add the basemap\nctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent of the map to the bounding box\nax.set_xlim(bbox_polygon_bm.total_bounds[0], bbox_polygon_bm.total_bounds[2])\nax.set_ylim(bbox_polygon_bm.total_bounds[1], bbox_polygon_bm.total_bounds[3])\n\n# Remove axes\nax.set_axis_off()\n\n# Add a legend for symbol sizes\nlegend_sizes = [0,4,8,12]  # Example sizes, adjust based on your data\nlegend_elements = [plt.scatter([], [], s=size*20, c='orangered', edgecolor='yellow', \n                               linewidth=1, alpha=1, label=f'{size:,}') \n                   for size in legend_sizes]\nax.legend(handles=legend_elements, title='Log Total Air Releases (lbs)', \n          loc='lower right', title_fontsize=12, fontsize=10)\n\nplt.title(\"Detroit Metro Area TRI Facilities - Total Air Releases (Custom Data)\", fontsize=16)\nplt.tight_layout()\nplt.show()\n\nprint(f\"\\nNumber of TRI facilities plotted: {len(gdf_tri_form_r)}\")\nprint(f\"Total air releases: {gdf_tri_form_r[release_col].sum():,.2f} lbs\")\nprint(f\"Average air release per facility: {gdf_tri_form_r[release_col].mean():,.2f} lbs\")\n\n\n\n\n\n\n\n\n\nNumber of TRI facilities plotted: 211\nTotal air releases: 2,117,167.80 lbs\nAverage air release per facility: 10,033.97 lbs\n\n\nThe point source air release data provides a good snapshot of the locations and relative amounts of chemical releases. With some basic understanding of the demographic dynamics of Detroit one might theorize who is being subjected to high levels of pollution, however, we’ll need additional data to develop any type of systematic analysis.\n\n\n\n\n\n\nKnowledge Check\n\n\n\nWhat key information does Form R of the Toxic Release Inventory provide?\n\nFacility names and locations only\nChemical storage capacities of facilities\nDetailed data on chemical releases, including air releases\nEmployee health records related to chemical exposure\n\n\n\n\n\nSocial Vulnerability Index\nNASA’s Social Vulnerability Index (SVI) raster dataset, available through the Socioeconomic Data and Applications Center (SEDAC), is a high-resolution geospatial resource that quantifies social vulnerability across the United States. This dataset is based on the CDC’s Social Vulnerability Index but is presented in a raster format, providing continuous coverage at a 250-meter resolution. The SVI incorporates various socioeconomic and demographic factors such as poverty, lack of vehicle access, crowded housing, and minority status to assess communities’ capacity to prepare for, respond to, and recover from hazards, including environmental threats like poor air quality.\nThe raster format allows for more detailed spatial analysis and integration with other environmental datasets. This makes it particularly valuable for researchers and policymakers studying the intersection of social vulnerability and environmental risks, such as air pollution exposure. By overlaying this SVI data with air quality information, for instance, analysts can identify areas where socially vulnerable populations may be disproportionately affected by poor air quality, supporting environmental justice initiatives and targeted intervention strategies.\nSEDAC, as part of NASA’s Earth Observing System Data and Information System (EOSDIS), hosts this dataset along with other socioeconomic and environmental data, facilitating interdisciplinary research on human-environment interactions. The SVI raster dataset’s high resolution and comprehensive coverage make it a powerful tool for assessing environmental equity and informing policy decisions at various geographic scales.\nAlthough the SVI dataset is free to acquire, it does require an Earth Data account. If you don’t already have an Earth Data account you can follow these steps to download the SVI dataset on your local computer:\n\nVisit the NASA Earthdata website: Go to https://urs.earthdata.nasa.gov/ Click on “Register”: Look for the “Register” button on the top right corner of the page.\nFill out the registration form: Provide the required information, including your name, email address, and a password. You’ll also need to create a username.\nVerify your email: NASA will send a verification email to the address you provided. Click on the link in this email to confirm your account.\nLog in to Earth Data: Once your account is verified, you can log in using your username and password.\nAccess SEDAC: Visit the SEDAC website (https://sedac.ciesin.columbia.edu/) and use your Earth Data credentials to log in when prompted.\nDownload the data: Once you’ve found the SVI dataset, you can use your Earth Data account to download it.\n\nRemember, your Earth Data account gives you access not just to SEDAC, but to a wide range of NASA Earth science data. It’s a valuable resource for researchers, students, and anyone interested in environmental and socioeconomic data.\n\nData Processing\nOnce you’ve downloaded the dataset to your working directory, you can proceed with the analysis. We’ll be using the 2020 census tract version of SVI.\nThe different layers of SVI are provided as individual files, but sometimes it’s easier to work with a multilayer object. We can create one using xarray. To begin, we’ll read in each file individually, clip it to our border of Detroit metro, and create an individual data array.\n\nimport xarray as xr\nimport rasterio\nimport rasterio.mask\n\nxr.set_options(\n    keep_attrs=True,\n    display_expand_attrs=True,\n    display_expand_coords=True,\n    display_expand_data=False,\n    display_expand_data_vars=True\n)\n\n# Specify the TIF files\ntif_files = [\n    \"data/svi/svi_2020_tract_overall_wgs84.tif\",\n    \"data/svi/svi_2020_tract_minority_wgs84.tif\",\n    \"data/svi/svi_2020_tract_socioeconomic_wgs84.tif\",\n    \"data/svi/svi_2020_tract_housing_wgs84.tif\",\n    \"data/svi/svi_2020_tract_household_wgs84.tif\"\n]\n\n# Create an empty list to store the individual DataArrays\ndata_arrays = []\n\n# Read each TIF file, clip it to Detroit metro's extent, and append it to the list\nfor file in tif_files:\n    with rasterio.open(file) as src:\n        # Reproject Detroit metro boundary to match the raster CRS\n        metro_reprojected = detroit_metro.to_crs(src.crs)\n        \n        # Clip the raster to Detroit metro's geometry\n        out_image, out_transform = rasterio.mask.mask(src, metro_reprojected.geometry, crop=True)\n        out_meta = src.meta.copy()\n        \n        # Update the metadata\n        out_meta.update({\"driver\": \"GTiff\",\n                         \"height\": out_image.shape[1],\n                         \"width\": out_image.shape[2],\n                         \"transform\": out_transform})\n        \n        # Create coordinates\n        height = out_meta['height']\n        width = out_meta['width']\n        cols, rows = np.meshgrid(np.arange(width), np.arange(height))\n        xs, ys = rasterio.transform.xy(out_transform, rows, cols)\n        \n        # Convert lists to numpy arrays\n        xs = np.array(xs)\n        ys = np.array(ys)\n        \n        # Reshape coordinates to match dimensions of the raster\n        xs = xs.reshape(height, width)\n        ys = ys.reshape(height, width)\n        \n        # Create a DataArray from the clipped data\n        da = xr.DataArray(out_image[0],  # Use the first band\n                          coords={'y': ('y', ys[:, 0]),\n                                  'x': ('x', xs[0, :])},\n                          dims=['y', 'x'])\n        da.attrs['crs'] = str(src.crs)  # Convert CRS to string\n        da.attrs['transform'] = out_transform\n        data_arrays.append(da)\n\nNow we can combine them together and give the layers “pretty” names.\n\n# Combine all DataArrays into a single DataSet\nsvi_detroit = xr.concat(data_arrays, dim='layer')\n\n# Rename the layers\nlayer_names = ['Overall', 'Minority', 'Socioeconomic', 'Housing', 'Household']\nsvi_detroit = svi_detroit.assign_coords(layer=('layer', layer_names))\nsvi_detroit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (layer: 5, y: 105, x: 119)&gt;\n-3.4e+38 -3.4e+38 -3.4e+38 -3.4e+38 ... -3.4e+38 -3.4e+38 -3.4e+38 -3.4e+38\nCoordinates:\n  * y        (y) float64 42.9 42.89 42.88 42.87 ... 42.05 42.05 42.04 42.03\n  * x        (x) float64 -83.69 -83.68 -83.67 -83.66 ... -82.72 -82.71 -82.7\n  * layer    (layer) &lt;U13 'Overall' 'Minority' ... 'Housing' 'Household'\nAttributes:\n    crs:        EPSG:4326\n    transform:  | 0.01, 0.00,-83.69|\\n| 0.00,-0.01, 42.90|\\n| 0.00, 0.00, 1.00|xarray.DataArraylayer: 5y: 105x: 119-3.4e+38 -3.4e+38 -3.4e+38 -3.4e+38 ... -3.4e+38 -3.4e+38 -3.4e+38array([[[-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        ...,\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38]],\n\n       [[-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n...\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38]],\n\n       [[-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        ...,\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38],\n        [-3.4e+38, -3.4e+38, -3.4e+38, ..., -3.4e+38, -3.4e+38,\n         -3.4e+38]]], dtype=float32)Coordinates: (3)y(y)float6442.9 42.89 42.88 ... 42.04 42.03array([42.895833, 42.887499, 42.879166, 42.870833, 42.862499, 42.854166,\n       42.845833, 42.837499, 42.829166, 42.820833, 42.812499, 42.804166,\n       42.795833, 42.787499, 42.779166, 42.770833, 42.762499, 42.754166,\n       42.745833, 42.737499, 42.729166, 42.720833, 42.712499, 42.704166,\n       42.695833, 42.687499, 42.679166, 42.670833, 42.662499, 42.654166,\n       42.645833, 42.637499, 42.629166, 42.620833, 42.612499, 42.604166,\n       42.595833, 42.587499, 42.579166, 42.570833, 42.562499, 42.554166,\n       42.545833, 42.537499, 42.529166, 42.520833, 42.512499, 42.504166,\n       42.495833, 42.487499, 42.479166, 42.470833, 42.462499, 42.454166,\n       42.445833, 42.437499, 42.429166, 42.420833, 42.412499, 42.404166,\n       42.395833, 42.387499, 42.379166, 42.370833, 42.362499, 42.354166,\n       42.345833, 42.337499, 42.329166, 42.320833, 42.312499, 42.304166,\n       42.295833, 42.287499, 42.279166, 42.270833, 42.262499, 42.254166,\n       42.245833, 42.237499, 42.229166, 42.220833, 42.212499, 42.204166,\n       42.195833, 42.187499, 42.179166, 42.170833, 42.162499, 42.154166,\n       42.145833, 42.137499, 42.129166, 42.120833, 42.112499, 42.104166,\n       42.095833, 42.087499, 42.079166, 42.070833, 42.062499, 42.054166,\n       42.045833, 42.037499, 42.029166])x(x)float64-83.69 -83.68 ... -82.71 -82.7array([-83.6875  , -83.679167, -83.670834, -83.6625  , -83.654167, -83.645834,\n       -83.6375  , -83.629167, -83.620834, -83.6125  , -83.604167, -83.595834,\n       -83.5875  , -83.579167, -83.570834, -83.5625  , -83.554167, -83.545834,\n       -83.5375  , -83.529167, -83.520834, -83.5125  , -83.504167, -83.495834,\n       -83.4875  , -83.479167, -83.470834, -83.4625  , -83.454167, -83.445834,\n       -83.4375  , -83.429167, -83.420834, -83.4125  , -83.404167, -83.395834,\n       -83.3875  , -83.379167, -83.370834, -83.3625  , -83.354167, -83.345834,\n       -83.3375  , -83.329167, -83.320834, -83.3125  , -83.304167, -83.295834,\n       -83.2875  , -83.279167, -83.270834, -83.2625  , -83.254167, -83.245834,\n       -83.2375  , -83.229167, -83.220834, -83.2125  , -83.204167, -83.195834,\n       -83.1875  , -83.179167, -83.170834, -83.1625  , -83.154167, -83.145834,\n       -83.1375  , -83.129167, -83.120834, -83.1125  , -83.104167, -83.095834,\n       -83.0875  , -83.079167, -83.070834, -83.0625  , -83.054167, -83.045834,\n       -83.0375  , -83.029167, -83.020834, -83.0125  , -83.004167, -82.995834,\n       -82.9875  , -82.979167, -82.970834, -82.9625  , -82.954167, -82.945834,\n       -82.9375  , -82.929167, -82.920834, -82.9125  , -82.904167, -82.895834,\n       -82.8875  , -82.879167, -82.870834, -82.8625  , -82.854167, -82.845834,\n       -82.8375  , -82.829167, -82.820834, -82.8125  , -82.804167, -82.795834,\n       -82.7875  , -82.779167, -82.770834, -82.7625  , -82.754167, -82.745834,\n       -82.7375  , -82.729167, -82.720834, -82.7125  , -82.704167])layer(layer)&lt;U13'Overall' ... 'Household'array(['Overall', 'Minority', 'Socioeconomic', 'Housing', 'Household'],\n      dtype='&lt;U13')Indexes: (3)yPandasIndexPandasIndex(Index([ 42.89583280200428,   42.8874994687043,  42.87916613540431,\n       42.870832802104324, 42.862499468804344,  42.85416613550436,\n        42.84583280220438,  42.83749946890439,  42.82916613560441,\n        42.82083280230442,\n       ...\n        42.10416613850579,   42.0958328052058,  42.08749947190582,\n       42.079166138605835, 42.070832805305855,  42.06249947200587,\n        42.05416613870588,   42.0458328054059, 42.037499472105914,\n       42.029166138805934],\n      dtype='float64', name='y', length=105))xPandasIndexPandasIndex(Index([-83.68750038476503, -83.67916705146503, -83.67083371816501,\n       -83.66250038486501, -83.65416705156501,   -83.645833718265,\n         -83.637500384965, -83.62916705166498, -83.62083371836498,\n       -83.61250038506496,\n       ...\n       -82.77916705506422,  -82.7708337217642,  -82.7625003884642,\n        -82.7541670551642, -82.74583372186419, -82.73750038856419,\n       -82.72916705526417, -82.72083372196417, -82.71250038866415,\n       -82.70416705536415],\n      dtype='float64', name='x', length=119))layerPandasIndexPandasIndex(Index(['Overall', 'Minority', 'Socioeconomic', 'Housing', 'Household'], dtype='object', name='layer'))Attributes: (2)crs :EPSG:4326transform :| 0.01, 0.00,-83.69|\n| 0.00,-0.01, 42.90|\n| 0.00, 0.00, 1.00|\n\n\nNow we can plot each layer.\n\n# Define the colorbar limits (SVI is a 0-1 scale)\nvmin, vmax = 0, 1\n\n# Create a multipanel plot\nfig, axes = plt.subplots(3, 2, figsize=(8, 10))\naxes = axes.flatten()\n\n# Plot each layer\nfor i, layer in enumerate(svi_detroit.layer.values):\n    # Plot with custom color limits\n    im = svi_detroit.sel(layer=layer).plot(ax=axes[i], add_colorbar=False, vmin=vmin, vmax=vmax, cmap='plasma')\n    axes[i].set_title(layer)\n    # Remove axes and labels\n    axes[i].axis('off')\n    \n    # Plot Detroit metro boundary\n    metro_reprojected.boundary.plot(ax=axes[i], color='red', linewidth=1)\n\n# Remove the extra subplot\nfig.delaxes(axes[5])\n\n# Add a single colorbar\ncbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])\ncbar = fig.colorbar(im, cax=cbar_ax, label='SVI Score', \n                    fraction=0.047, pad=0.04, aspect=20)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nThis provides an excellent look at demographic trends in the Detroit metro area. Overall vulnerability is highest in the inner city. The most striking drivers are the concentration of minorities and socioeconomic vulnerability in the downtown area. The housing and household components are slightly more varied throughout the region.\n\n\n\n\n\n\nKnowledge Check\n\n\n\nWhat does the Social Vulnerability Index (SVI) primarily measure?\n\nAir pollution levels in different communities\nEconomic growth rates of different regions\nCommunities’ capacity to prepare for and respond to hazards\nPopulation density in urban areas\n\n\n\n\n\n\nIntegrating TRI and SVI\nThere are numerous ways to assess the reationships between the SVI and TRI data. For this lesson we’ll identify areas where air releases and vulnerability are highest together by creating a new rasterized index that combines both layers.\nTo begin we need to rasterize the air release point data. We will create an empty raster grid and “fill” the cells with the sum of the air release values from any points the are overlapped by the cells.\nStart by getting the bounds from our boundary object, specify the desired resolution, and set up the transform.\n\nfrom rasterio.transform import from_origin\n\n# Get the bounds of the Detroit metro area\nminx, miny, maxx, maxy = detroit_metro_bm.total_bounds\n\n# Define the resolution (1km/1000m) to match SVI\nresolution = 5000\n\n# Calculate the number of cells\nnx = int((maxx - minx) / resolution)\nny = int((maxy - miny) / resolution)\n\n# Create the transform for the raster\ntransform = from_origin(minx, maxy, resolution, resolution)\n\nNow we have to prepare the point values and rasterize them. A key thing to note here is the merge_alg=rasterio.enums.MergeAlg.add argument passed to the rasterize function. This makes sure that cells with more than 1 point will add the values together (the default is to simply replace).\n\nfrom rasterio import features\n\n# Prepare geometries and values for rasterization\nshapes = ((geom, value) for geom, value in zip(gdf_tri_form_r_bm.geometry, gdf_tri_form_r_bm.AIR_TOTAL_RELEASE))\n\n# Rasterize the point data\nair_release_raster = features.rasterize(shapes=shapes, \n                            out_shape=(ny, nx), \n                            transform=transform, \n                            fill=0, \n                            all_touched=True, \n                            merge_alg=rasterio.enums.MergeAlg.add)\n\nWe rasterized with rasterio, but we need to convert this to an xarray object to continue and we need rioxarray to write the crs information for the xarray object.\n\nimport rioxarray\n\n# Convert the raster to an xarray DataArray\n# Note: We use ny and nx here to ensure the coordinates match the raster shape\nair_release_raster_da = xr.DataArray(air_release_raster, \n                         coords={'y': np.linspace(maxy, miny, ny),\n                                 'x': np.linspace(minx, maxx, nx)},\n                         dims=['y', 'x'])\nair_release_raster_da.rio.write_crs(detroit_metro_bm.crs, inplace=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray (y: 26, x: 21)&gt;\n0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 4.97 0.0 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0\nCoordinates:\n  * y            (y) float64 5.296e+06 5.291e+06 ... 5.17e+06 5.165e+06\n  * x            (x) float64 -9.316e+06 -9.311e+06 ... -9.212e+06 -9.207e+06\n    spatial_ref  int32 0xarray.DataArrayy: 26x: 210.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ... 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0array([[0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        4.9699998e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00],\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 5.1500000e+02, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00],\n       [0.0000000e+00, 0.0000000e+00, 4.9599999e-01, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 4.0000000e+01,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00],\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 3.5800001e-01,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n...\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00],\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 6.8400000e+02, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00],\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 1.9386000e+04, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00],\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00, 0.0000000e+00, 0.0000000e+00,\n        0.0000000e+00]], dtype=float32)Coordinates: (3)y(y)float645.296e+06 5.291e+06 ... 5.165e+06array([5296389.872502, 5291140.826115, 5285891.779728, 5280642.73334 ,\n       5275393.686953, 5270144.640565, 5264895.594178, 5259646.547791,\n       5254397.501403, 5249148.455016, 5243899.408629, 5238650.362241,\n       5233401.315854, 5228152.269466, 5222903.223079, 5217654.176692,\n       5212405.130304, 5207156.083917, 5201907.037529, 5196657.991142,\n       5191408.944755, 5186159.898367, 5180910.85198 , 5175661.805593,\n       5170412.759205, 5165163.712818])x(x)float64-9.316e+06 ... -9.207e+06array([-9316264.759986, -9310790.760229, -9305316.760472, -9299842.760715,\n       -9294368.760958, -9288894.761201, -9283420.761444, -9277946.761687,\n       -9272472.76193 , -9266998.762172, -9261524.762415, -9256050.762658,\n       -9250576.762901, -9245102.763144, -9239628.763387, -9234154.76363 ,\n       -9228680.763873, -9223206.764116, -9217732.764359, -9212258.764602,\n       -9206784.764845])spatial_ref()int320crs_wkt :PROJCS[\"WGS 84 / Pseudo-Mercator\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Mercator_1SP\"],PARAMETER[\"central_meridian\",0],PARAMETER[\"scale_factor\",1],PARAMETER[\"false_easting\",0],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],EXTENSION[\"PROJ4\",\"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs\"],AUTHORITY[\"EPSG\",\"3857\"]]spatial_ref :PROJCS[\"WGS 84 / Pseudo-Mercator\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Mercator_1SP\"],PARAMETER[\"central_meridian\",0],PARAMETER[\"scale_factor\",1],PARAMETER[\"false_easting\",0],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],EXTENSION[\"PROJ4\",\"+proj=merc +a=6378137 +b=6378137 +lat_ts=0 +lon_0=0 +x_0=0 +y_0=0 +k=1 +units=m +nadgrids=@null +wktext +no_defs\"],AUTHORITY[\"EPSG\",\"3857\"]]array(0)Indexes: (2)yPandasIndexPandasIndex(Index([ 5296389.872502303,  5291140.826114924,  5285891.779727546,\n       5280642.7333401665,  5275393.686952787,  5270144.640565409,\n         5264895.59417803,  5259646.547790651,  5254397.501403273,\n        5249148.455015894,  5243899.408628515,  5238650.362241137,\n        5233401.315853758,  5228152.269466379,     5222903.223079,\n        5217654.176691622, 5212405.1303042425,  5207156.083916863,\n        5201907.037529485,  5196657.991142106,  5191408.944754727,\n        5186159.898367349,   5180910.85197997,  5175661.805592591,\n        5170412.759205213,  5165163.712817834],\n      dtype='float64', name='y'))xPandasIndexPandasIndex(Index([-9316264.759986106, -9310790.760229032, -9305316.760471959,\n       -9299842.760714887, -9294368.760957813,  -9288894.76120074,\n       -9283420.761443667, -9277946.761686593,  -9272472.76192952,\n       -9266998.762172446, -9261524.762415372,   -9256050.7626583,\n       -9250576.762901226, -9245102.763144152,  -9239628.76338708,\n       -9234154.763630006, -9228680.763872933, -9223206.764115859,\n       -9217732.764358785, -9212258.764601713,  -9206784.76484464],\n      dtype='float64', name='x'))Attributes: (0)\n\n\nThe spaces between county borders can create odd values because there are no points right next to each other. We can clip the raster to our Detroit boundary to fix this.\n\n# Clip the raster with the Detroit metro boundary\nair_release_raster_da = air_release_raster_da.rio.clip(\n    detroit_metro_bm.geometry.values, \n    detroit_metro_bm.crs, \n    drop=False, all_touched=True)\n\nNow we can see how our rasterized air release values look.\n\nfrom matplotlib.colors import BoundaryNorm, ListedColormap\n\n# Define the breaks for the discrete scale\nbreaks = [0, 1, 10, 100, 1000, 10000, 100000, 250000, 500000]\n\n# Create a custom colormap\ncolors = ['#fffff3', '#FFFFCC', '#FFEDA0', '#FED976', '#FEB24C', '#FD8D3C', '#FC4E2A', '#E31A1C', '#B10026']\ncmap = ListedColormap(colors)\n\n# Create a normalization based on the breaks\nnorm = BoundaryNorm(breaks, cmap.N)\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(7, 7))\n\n# Plot the TRI facility points\ngdf_tri_form_r_bm.plot(ax=ax, color='blue', markersize=10, alpha=0.7)\n\n# Plot the clipped raster with the custom colormap and norm\nim = ax.imshow(air_release_raster_da, extent=[minx, maxx, miny, maxy], origin='upper', \n               cmap=cmap, norm=norm)\n\n# Add colorbar with discrete labels\ncbar = plt.colorbar(im, ax=ax, extend='max', \n                    label='Total Air Releases (pounds)', \n                    ticks=breaks, \n                    fraction=0.047, pad=0.04, aspect=20)\ncbar.ax.set_yticklabels([f'{b:,}' for b in breaks])\n\n# Plot the Detroit metro boundary\ndetroit_metro_bm.boundary.plot(ax=ax, color='black', linewidth=2)\n\n# Set the extent to match the Detroit metro area\nax.set_xlim(minx, maxx)\nax.set_ylim(miny, maxy)\n\n# Add title and labels\nax.set_title('TRI Air Total Release (100m resolution sum) with Facility Locations', fontsize=16)\nax.set_xlabel('X Coordinate')\nax.set_ylabel('Y Coordinate')\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"Number of TRI facilities plotted: {len(gdf_tri_form_r_bm)}\")\nprint(f\"Total air releases: {gdf_tri_form_r_bm['AIR_TOTAL_RELEASE'].sum():,.2f}\")\nprint(f\"Maximum cell value in raster: {air_release_raster_da.max().values:,.2f}\")\n\n\n\n\n\n\n\n\nNumber of TRI facilities plotted: 211\nTotal air releases: 2,117,167.80\nMaximum cell value in raster: 434,344.84\n\n\nThe raster looks as expected with the highest values in locations where our previous map had the largest circles. We overlayed the points to see the sources of the values. The cell resolution is set to 5000m. This was selected so we can evaluate the map and the process we used to create the raster, but any value could be set depending on the intended use.\n\nAir Release Vulnerability Index\nNow that we’ve created our air release raster layer we can combine it with the SVI raster to create a new index identifying areas with the highest combination of air releases and vulnerability.\nStart by selecting just the SVI Overall layer and converting it to a rioxarray object so we can perform raster calculations. We’ll also ensure the 2 raster layers “line up” by reprojecting into the same coordinate reference system and matching their resolutions.\n\nfrom rasterio.enums import Resampling\n\n# Select the 'Overall' layer\nsvi_overall = svi_detroit.sel(layer='Overall')\n\n# Convert to rioxarray for geospatial operations\nsvi_overall = svi_overall.rio.write_crs(\"EPSG:4326\")\n\n# Reproject SVI to match the CRS of the air release raster\nsvi_reprojected = svi_overall.rio.reproject_match(air_release_raster_da)\n\n# Disaggregate the air release data to match the resolution of the SVI data\nair_release_disaggregated = svi_reprojected.rio.reproject_match(\n    svi_reprojected,\n    resampling=Resampling.bilinear\n)\n\nThere are a few more steps that will aid in interpretation.\n\nWe will take the log of the air release data to reduce the impact of major outliers.\nWe will scale the logged air release data to 0-1 to match the SVI data. Now the resulting index we create will have equal contributions from both datasets.\n\n\n# Log1p transform the air release data and scale to 0-1\nair_release_log = np.log1p(air_release_disaggregated)\nair_release_scaled = (air_release_log - air_release_log.min()) / (air_release_log.max() - air_release_log.min())\n\n# Multiply scaled air release data with SVI data\nvulnerability_indicator = air_release_scaled * svi_reprojected\n\nNow let’s visualize our index along with the inputs.\n\n# Create the plots\nfig, axs = plt.subplots(3, 1, figsize=(8, 20))\n\n# Plot SVI Overall\nim1 = svi_reprojected.plot(ax=axs[0], cmap='viridis', vmin=0, vmax=1, add_colorbar=False)\nplt.colorbar(im1, ax=axs[0], label='SVI Overall', \n                    fraction=0.047, pad=0.04, aspect=20)\naxs[0].set_title('Social Vulnerability Index (Overall)', fontsize=16)\ndetroit_metro.boundary.plot(ax=axs[0], color='black', linewidth=2)\n\n# Plot Original Air Release (log-transformed for better visualization)\nim2 = np.log1p(air_release_disaggregated).plot(ax=axs[1], cmap='YlOrRd', add_colorbar=False)\nplt.colorbar(im2, ax=axs[1], label='Log(Air Release + 1)', \n                    fraction=0.047, pad=0.04, aspect=20)\naxs[1].set_title('Air Release (Log-transformed)', fontsize=16)\ndetroit_metro.boundary.plot(ax=axs[1], color='black', linewidth=2)\n\n# Plot Air Release Vulnerability Indicator\nim3 = vulnerability_indicator.plot(ax=axs[2], cmap='YlOrRd', vmin=0, vmax=1, add_colorbar=False)\nplt.colorbar(im3, ax=axs[2], label='Air Release Vulnerability Indicator', \n                    fraction=0.047, pad=0.04, aspect=20)\naxs[2].set_title('Air Release Vulnerability Indicator\\n(Scaled Air Release * SVI)', fontsize=16)\ndetroit_metro.boundary.plot(ax=axs[2], color='black', linewidth=2)\n\nfor ax in axs:\n    ax.set_xlabel('Longitude')\n    ax.set_ylabel('Latitude')\n    ax.set_xlim(svi_reprojected.x.min(), svi_reprojected.x.max())\n    ax.set_ylim(svi_reprojected.y.min(), svi_reprojected.y.max())\n\nplt.tight_layout()\nplt.show()\n\n# Print some statistics\nprint(f\"Maximum vulnerability indicator: {vulnerability_indicator.max().values:.4f}\")\n\n\n\n\n\n\n\n\nMaximum vulnerability indicator: 0.9773\n\n\nAs one would expect, there are several areas in the downtown river corridor with very high combinations of SVI and TRI releases. The maximum score for our index is 0.9286! That is an extremely vulnerable community facing extraordinary levels of air pollution.\nWe can get a better sense of where these communities are by extracting the location of the cells with the highest scores and placing them on a basemap of Detroit.\nWe’ll convert the raster into a data frame, sort the values in descending order, and then extract the coordinates.\n\n# Convert the vulnerability indicator to a pandas DataFrame\nvulnerability_df = vulnerability_indicator.to_dataframe(name='index').reset_index()\n\n# Sort by index value and get the top 10\ntop_10 = vulnerability_df.sort_values('index', ascending=False).head(10)\n\n# Create points from the coordinates\ntop_10['geometry'] = gpd.points_from_xy(top_10.x, top_10.y)\ntop_10_gdf = gpd.GeoDataFrame(top_10, geometry='geometry', crs=vulnerability_indicator.rio.crs)\n\nNow let’s make a map.\n\n# Create the final map\nfig, ax = plt.subplots(figsize=(8, 8))\n\n# Plot the Detroit metro boundary\ndetroit_metro_bm.boundary.plot(ax=ax, color='black', linewidth=2)\n\n# Plot the top 10 points\ntop_10_gdf.plot(ax=ax, color='blue', markersize=100, alpha=0.7)\n\n# Add labels to the points\nfor idx, row in top_10_gdf.iterrows():\n    ax.annotate(f\"#{idx+1}\", (row.geometry.x, row.geometry.y), \n                xytext=(3, 3), textcoords=\"offset points\", \n                color='black', fontweight='bold')\n\n# Add a basemap\nctx.add_basemap(ax, crs=vulnerability_indicator.rio.crs.to_string(), source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Add a border to the map\nbbox_polygon_bm.boundary.plot(ax=ax, color='#315c86', linewidth=3)\n\n# Set the extent to match the Detroit metro area\nax.set_xlim(vulnerability_indicator.x.min(), vulnerability_indicator.x.max())\nax.set_ylim(vulnerability_indicator.y.min(), vulnerability_indicator.y.max())\n\nax.set_title('Top 10 Areas with Highest Air Release Vulnerability Index', fontsize=16)\nax.set_axis_off()\n\nplt.tight_layout()\nplt.show()\n\n# Print the row index and index value of the top 10 points\nprint(\"Row index and index value of the top 10 points:\")\nfor i, (idx, row) in enumerate(top_10_gdf.iterrows(), 1):\n    print(f\"Row index = {idx}, Index value = {round(row['index'], 2)}\")\n\n\n\n\n\n\n\n\nRow index and index value of the top 10 points:\nRow index = 347, Index value = 0.98\nRow index = 134, Index value = 0.97\nRow index = 155, Index value = 0.97\nRow index = 306, Index value = 0.96\nRow index = 369, Index value = 0.96\nRow index = 305, Index value = 0.94\nRow index = 285, Index value = 0.94\nRow index = 330, Index value = 0.93\nRow index = 348, Index value = 0.92\nRow index = 324, Index value = 0.9\n\n\nAs you would expect looking at the input layers, the most vulnerable and polluted areas are along the river coridor in Loncoln Park, Melvindale, Mexicantown, and River Rouge. There are multiple locations with indexes greater than 0.70. Information like this can be valuable for targeted relief or mitigation programs.\n\n\n\n\n\n\nKnowledge Check\n\n\n\nWhat was the main purpose of combining the TRI and SVI data in this analysis?\n\nTo calculate total pollution levels for each county\nTo identify areas with both high air releases and high social vulnerability\nTo determine the most populous areas in Detroit\nTo predict future industrial development zones\n\n\n\n\n\n\nCDC PLACES\nThe CDC PLACES (Population Level Analysis and Community Estimates) dataset is a collaboration between the Centers for Disease Control and Prevention (CDC), the Robert Wood Johnson Foundation, and the CDC Foundation. It provides model-based population-level analysis and community estimates of health indicators for all counties, places (incorporated and census designated places), census tracts, and ZIP Code Tabulation Areas (ZCTAs) across the United States. Some key points to consider when working with CDC PLACES:\n\nSpatial Extent: Entire United States, including all 50 states, the District of Columbia, and Puerto Rico.\nSpatial Resolution: Multiple levels including counties, cities/towns, census tracts, and ZIP codes.\nIndicators: Wide range of chronic disease measures related to health outcomes, prevention, and health risk behaviors.\nData Sources:\n\nBehavioral Risk Factor Surveillance System (BRFSS)\nU.S. Census Bureau’s American Community Survey (ACS)\n\nMethodology: Uses small area estimation methods for small geographic areas.\nHealth Measures Include:\n\nChronic diseases: e.g., asthma, COPD, heart disease, diabetes\nHealth risk behaviors: e.g., smoking, physical inactivity, binge drinking\nPrevention practices: e.g., health insurance coverage, dental visits, cholesterol screening\n\nSocioeconomic Data: Includes some socioeconomic and demographic variables.\nAnnual Updates: Providing recent estimates for local areas.\n\nThis dataset is valuable for public health researchers, policymakers, and community organizations. It provides a standardized way to compare health indicators across different geographic areas and can be used to inform targeted interventions and policy decisions, especially in addressing health disparities at a local level.\nAs with ICIS-AIR and TRI, PLACES is available through a web search interface and a programmatic API. We will focus on the API in this example.\n\nProcessing\nWe’ll start by accessing the CDC PLACES data through their API and processing it for our analysis. First we set up our API request. We specify the endpoint URL, define our target counties, and create a filter to select data only for these counties in Michigan.\n\n# Define the GeoJSON API endpoint\nurl = \"https://data.cdc.gov/resource/cwsq-ngmh.geojson\"\n\n# Define the Detroit metro area counties\ndetroit_counties = ['Wayne', 'Oakland', 'Macomb']\n\n# Create the county filter string\ncounty_filter = \" OR \".join([f\"countyname = '{county}'\" for county in detroit_counties])\n\n# Define the query parameters\nparams = {\n    \"$where\": f\"stateabbr = 'MI' AND ({county_filter})\",\n    \"$limit\": 50000  # Adjust if necessary\n}\n\nNext, let’s make the API request and process the response:\n\n# Make the API request\nresponse = requests.get(url, params=params)\n\nif response.status_code == 200:\n    data = response.json()\n    print(f\"Successfully retrieved data\")\nelse:\n    print(f\"Failed to retrieve data. Status code: {response.status_code}\")\n    print(response.text)\n\n# Convert to GeoDataFrame\ngdf = gpd.read_file(response.text)\n\nSuccessfully retrieved data\n\n\nYou can inspect the gdf return object on your own; it’s too large to print here. Let’s just take a look at the available health measures in CDC PLACES.\n\n# Print available health measures\nprint(\"\\nAvailable health measures:\")\nprint(gdf['measure'].unique())\n\n# Print basic information about the GeoDataFrame\nprint(\"\\nGeoDataFrame Info:\")\nprint(gdf.info())\n\n\nAvailable health measures:\n['Frequent physical distress among adults'\n 'Cancer (non-skin) or melanoma among adults'\n 'Visited dentist or dental clinic in the past year among adults'\n 'Cognitive disability among adults' 'Coronary heart disease among adults'\n 'Current asthma among adults'\n 'Current lack of health insurance among adults aged 18-64 years'\n 'Lack of social and emotional support among adults'\n 'Arthritis among adults' 'Obesity among adults'\n 'Self-care disability among adults' 'Mobility disability among adults'\n 'Short sleep duration among adults'\n 'Frequent mental distress among adults'\n 'Fair or poor self-rated health status among adults'\n 'Lack of reliable transportation in the past 12 months among adults'\n 'All teeth lost among adults aged &gt;=65 years'\n 'Taking medicine to control high blood pressure among adults with high blood pressure'\n 'Colorectal cancer screening among adults aged 45–75 years'\n 'Vision disability among adults'\n 'Visits to doctor for routine checkup within the past year among adults'\n 'Diagnosed diabetes among adults'\n 'Mammography use among women aged 50-74 years'\n 'Independent living disability among adults'\n 'Hearing disability among adults' 'Stroke among adults'\n 'Chronic obstructive pulmonary disease among adults'\n 'Food insecurity in the past 12 months among adults'\n 'Feeling socially isolated among adults'\n 'High cholesterol among adults who have ever been screened'\n 'High blood pressure among adults'\n 'No leisure-time physical activity among adults'\n 'Cholesterol screening among adults'\n 'Housing insecurity in the past 12 months among adults'\n 'Utility services shut-off threat in the past 12 months among adults'\n 'Binge drinking among adults'\n 'Received food stamps in the past 12 months among adults'\n 'Current cigarette smoking among adults' 'Any disability among adults'\n 'Depression among adults']\n\nGeoDataFrame Info:\n&lt;class 'geopandas.geodataframe.GeoDataFrame'&gt;\nRangeIndex: 46560 entries, 0 to 46559\nData columns (total 24 columns):\n #   Column                      Non-Null Count  Dtype   \n---  ------                      --------------  -----   \n 0   measure                     46560 non-null  object  \n 1   low_confidence_limit        46560 non-null  object  \n 2   data_value_unit             46560 non-null  object  \n 3   data_value                  46560 non-null  object  \n 4   short_question_text         46560 non-null  object  \n 5   statedesc                   46560 non-null  object  \n 6   totalpop18plus              46560 non-null  object  \n 7   locationid                  46560 non-null  object  \n 8   countyname                  46560 non-null  object  \n 9   year                        46560 non-null  object  \n 10  high_confidence_limit       46560 non-null  object  \n 11  categoryid                  46560 non-null  object  \n 12  stateabbr                   46560 non-null  object  \n 13  data_value_footnote         0 non-null      object  \n 14  data_value_type             46560 non-null  object  \n 15  data_value_footnote_symbol  0 non-null      object  \n 16  locationname                46560 non-null  object  \n 17  category                    46560 non-null  object  \n 18  datavaluetypeid             46560 non-null  object  \n 19  measureid                   46560 non-null  object  \n 20  countyfips                  46560 non-null  object  \n 21  datasource                  46560 non-null  object  \n 22  totalpopulation             46560 non-null  object  \n 23  geometry                    46560 non-null  geometry\ndtypes: geometry(1), object(23)\nmemory usage: 8.5+ MB\nNone\n\n\nThere’s a lot of great data here considering the rarity of health outcomes data; especially at this resolution (census tracts). Because we’re dealing with air quality in this lesson we’ll use “Current asthma among adults.”\nLet’s make a quick map to see how it looks.\n\n# Create a sample map for one health measure (e.g., Current asthma)\nfig, ax = plt.subplots(figsize=(7, 7))\n\n# Filter for the specific measure and ensure data_value is numeric\ngdf_asthma = gdf[gdf['measure'] == 'Current asthma among adults'].copy()\ngdf_asthma['data_value'] = pd.to_numeric(gdf_asthma['data_value'], errors='coerce')\n\n# Plot the asthma data\ngdf_asthma.plot(column='data_value', \n                ax=ax, \n                legend=True, \n                legend_kwds={'label': 'Asthma Prevalence (%)', 'orientation': 'horizontal'},\n                cmap='YlOrRd',\n                missing_kwds={'color': 'lightgrey'})\n\n# Add basemap\nctx.add_basemap(ax, crs=gdf_asthma.crs.to_string(), source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Add a border to the map\nbbox_polygon_bm.boundary.plot(ax=ax, color='#315c86', linewidth=3)\n\n# Set the extent to match the Detroit metro area\nax.set_xlim(gdf_asthma.total_bounds[0], gdf_asthma.total_bounds[2])\nax.set_ylim(gdf_asthma.total_bounds[1], gdf_asthma.total_bounds[3])\n\nplt.title('Asthma Prevalence in Detroit Metro Area', fontsize=16)\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nIf you hadn’t already noticed while inspecting the object we returned from the API, the census tract data are actually centroid points–not census tract boundaries.\nWe created a choropleth map showing asthma prevalence across the Detroit metro area. With the YlOrRd colormap darker red indicates higher asthma prevalence.\nFinally, let’s print some statistics about the asthma data:\n\n# Print some statistics for the asthma data\nprint(\"\\nAsthma Statistics:\")\nprint(f\"Average asthma prevalence: {gdf_asthma['data_value'].mean():.2f}%\")\nprint(f\"Minimum asthma prevalence: {gdf_asthma['data_value'].min():.2f}%\")\nprint(f\"Maximum asthma prevalence: {gdf_asthma['data_value'].max():.2f}%\")\n\n# Print the number of census tracts per county\nprint(\"\\nNumber of census tracts per county:\")\nprint(gdf_asthma['countyname'].value_counts())\n\n\nAsthma Statistics:\nAverage asthma prevalence: 12.06%\nMinimum asthma prevalence: 7.20%\nMaximum asthma prevalence: 17.20%\n\nNumber of census tracts per county:\ncountyname\nWayne      583\nOakland    345\nMacomb     236\nName: count, dtype: int64\n\n\nWow. Some census tracts along the river front and central downtown area have adult asthma prevalance of nearly 20%! I’m not an epidimeologist, but that seems extremely high; especially when you compare to the outer suburbs and more affluent areas in the Royal Oak-Ferndale area. However, in light of our exploration of TRI and ICIS-AIR data it might not be surprising to see elevated asthma rates in these areas.\nGiven that we’ve mostly been working with and creating raster data in the previous sections, it might be easier to draw systematic comparisons between pollution and health outcomes if the CDC data is also in a raster format.\n\n\nInterpolate a Surface w/ IDW\nWhile the choropleth map provides a good overview, it can be affected by the varying sizes of census tracts. To get a smoother representation of the data that resembles our air quality data, we can use Inverse Distance Weighting (IDW) interpolation to create a continuous surface.\nFirst, let’s prepare our data for interpolation by reprojecting, extracting the coordinates and the asthma value, and masking the data for any asthma values that may be NA.\n\nfrom scipy.interpolate import griddata\nfrom rasterio.transform import from_origin\nfrom rasterio.warp import transform_bounds\n\n# Ensure gdf_asthma is in EPSG:4326\ngdf_asthma = gdf_asthma.to_crs(epsg=4326)\n\n# Extract coordinates and values\nX = gdf_asthma.geometry.x.values\nY = gdf_asthma.geometry.y.values\nZ = gdf_asthma['data_value'].values\n\n# Remove any NaN values\nmask = ~np.isnan(Z)\nX, Y, Z = X[mask], Y[mask], Z[mask]\n\n\n\n\n\n\n\n\n\nData Science Review\n\n\n\nInverse Distance Weighting (IDW) is a spatial interpolation method used to estimate values at unknown locations based on known values at nearby points. The fundamental principle of IDW is that points closer to the location being estimated have more influence than those farther away. IDW calculates the estimated value as a weighted average of nearby known values, with weights inversely proportional to the distance between the known point and the estimation location. IDW is popular in geographic information systems (GIS) and environmental sciences due to its simplicity and effectiveness in creating continuous surfaces from point data, such as elevation, temperature, or pollution levels. While IDW has advantages like preserving local variation and working well with evenly distributed points, it also has limitations; including potential “bull’s-eye” patterns around data points, inability to account for spatial trends or barriers, and sensitivity to outliers and clustering of input points.\n\n\nNow we create the structure of the raster we’ll create. This is based on our desired resolution and the extent of our data.\n\n# Create a grid to interpolate over\n# Resolution (degrees)\ngrid_resolution = 0.025\n# Extent\nx_min, y_min, x_max, y_max = gdf_asthma.total_bounds\n# Arrange the locations of the x and y dimensions\ngrid_x = np.arange(x_min, x_max, grid_resolution)\ngrid_y = np.arange(y_min, y_max, grid_resolution)\n# Mesh them to a grid\ngrid_xx, grid_yy = np.meshgrid(grid_x, grid_y)\n\nNow we’re ready to interpolate the surface.\n\n# Perform IDW interpolation\npoints = np.column_stack((X, Y))\ngrid_z = griddata(points, Z, (grid_xx, grid_yy), method='linear')\n\nThis created a regular grid over our study area and then used the griddata function to perform linear interpolation (which is a form of IDW) on our asthma prevalence data.\nNow, let’s convert our interpolated data into an xarray Dataset so it’s easier to manipulate.\n\n# Create an xarray Dataset from the interpolated data\nds = xr.Dataset({\n    'asthma': (['y', 'x'], grid_z),\n    'x': grid_x,\n    'y': grid_y\n})\n\n# Set the correct CRS\nds.rio.write_crs(\"EPSG:4326\", inplace=True)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt;\nDimensions:      (y: 33, x: 38)\nCoordinates:\n  * x            (x) float64 -83.67 -83.64 -83.62 ... -82.79 -82.77 -82.74\n  * y            (y) float64 42.06 42.09 42.11 42.14 ... 42.79 42.81 42.84 42.86\n    spatial_ref  int32 0\nData variables:\n    asthma       (y, x) float64 nan nan nan nan nan nan ... nan nan nan nan nanxarray.DatasetDimensions:y: 33x: 38Coordinates: (3)x(x)float64-83.67 -83.64 ... -82.77 -82.74array([-83.665503, -83.640503, -83.615503, -83.590503, -83.565503, -83.540503,\n       -83.515503, -83.490503, -83.465503, -83.440503, -83.415503, -83.390503,\n       -83.365503, -83.340503, -83.315503, -83.290503, -83.265503, -83.240503,\n       -83.215503, -83.190503, -83.165503, -83.140503, -83.115503, -83.090503,\n       -83.065503, -83.040503, -83.015503, -82.990503, -82.965503, -82.940503,\n       -82.915503, -82.890503, -82.865503, -82.840503, -82.815503, -82.790503,\n       -82.765503, -82.740503])y(y)float6442.06 42.09 42.11 ... 42.84 42.86array([42.060038, 42.085038, 42.110038, 42.135038, 42.160038, 42.185038,\n       42.210038, 42.235038, 42.260038, 42.285038, 42.310038, 42.335038,\n       42.360038, 42.385038, 42.410038, 42.435038, 42.460038, 42.485038,\n       42.510038, 42.535038, 42.560038, 42.585038, 42.610038, 42.635038,\n       42.660038, 42.685038, 42.710038, 42.735038, 42.760038, 42.785038,\n       42.810038, 42.835038, 42.860038])spatial_ref()int320crs_wkt :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984grid_mapping_name :latitude_longitudespatial_ref :GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0,AUTHORITY[\"EPSG\",\"8901\"]],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AXIS[\"Latitude\",NORTH],AXIS[\"Longitude\",EAST],AUTHORITY[\"EPSG\",\"4326\"]]array(0)Data variables: (1)asthma(y, x)float64nan nan nan nan ... nan nan nan nanarray([[        nan,         nan,         nan, ...,         nan,\n                nan,         nan],\n       [        nan,         nan,         nan, ...,         nan,\n                nan,         nan],\n       [        nan,         nan,         nan, ...,         nan,\n                nan,         nan],\n       ...,\n       [        nan,         nan, 11.45419847, ..., 11.48577223,\n        11.91445179,         nan],\n       [        nan,         nan, 11.36882026, ..., 11.54773592,\n                nan,         nan],\n       [        nan,         nan,         nan, ...,         nan,\n                nan,         nan]])Indexes: (2)xPandasIndexPandasIndex(Index([        -83.665503,         -83.640503, -83.61550299999999,\n       -83.59050299999998, -83.56550299999998, -83.54050299999997,\n       -83.51550299999997, -83.49050299999996, -83.46550299999996,\n       -83.44050299999995, -83.41550299999994, -83.39050299999994,\n       -83.36550299999993, -83.34050299999993, -83.31550299999992,\n       -83.29050299999992, -83.26550299999991,  -83.2405029999999,\n        -83.2155029999999,  -83.1905029999999, -83.16550299999989,\n       -83.14050299999988, -83.11550299999988, -83.09050299999987,\n       -83.06550299999986, -83.04050299999986, -83.01550299999985,\n       -82.99050299999985, -82.96550299999984, -82.94050299999984,\n       -82.91550299999983, -82.89050299999982, -82.86550299999982,\n       -82.84050299999981, -82.81550299999981,  -82.7905029999998,\n        -82.7655029999998, -82.74050299999979],\n      dtype='float64', name='x'))yPandasIndexPandasIndex(Index([        42.0600376,         42.0850376,         42.1100376,\n               42.1350376, 42.160037599999995, 42.185037599999994,\n        42.21003759999999,  42.23503759999999,  42.26003759999999,\n        42.28503759999999,  42.31003759999999, 42.335037599999986,\n       42.360037599999984,  42.38503759999998,  42.41003759999998,\n        42.43503759999998,  42.46003759999998,  42.48503759999998,\n       42.510037599999976, 42.535037599999974,  42.56003759999997,\n        42.58503759999997,  42.61003759999997,  42.63503759999997,\n        42.66003759999997, 42.685037599999966, 42.710037599999964,\n        42.73503759999996,  42.76003759999996,  42.78503759999996,\n        42.81003759999996,  42.83503759999996, 42.860037599999956],\n      dtype='float64', name='y'))Attributes: (0)\n\n\nThis step allows us to work with our interpolated data using xarray, which provides powerful tools for working with multi-dimensional arrays.\nNext, we’ll clip our interpolated surface to the Detroit metro area. This ensures our data matches our other rasters. Then we’ll project it to match basemaps so we can create a map of the data.\n\n# Clip the dataset using the detroit_metro polygon\nds_clipped = ds.rio.clip(detroit_metro.geometry, drop=False)\n\n# Reproject to Web Mercator (EPSG:3857)\nds_3857 = ds_clipped.rio.reproject(\"EPSG:3857\")\n\nFinally, let’s create a map of our interpolated asthma prevalence:\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(7, 7))\n\n# Plot the interpolated and clipped data\nim = ds_3857.asthma.plot(ax=ax, cmap='YlOrRd', \n                         alpha=0.7, add_colorbar=False)\n\n# Add colorbar with adjusted height\ncbar = plt.colorbar(im, ax=ax, label='Asthma Prevalence', \n                    fraction=0.047, pad=0.04, aspect=20)\n\n# Add basemap\nctx.add_basemap(ax, crs=ds_3857.rio.crs, \n                source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Add a border to the map\nbbox_polygon_bm.boundary.plot(ax=ax, color='#315c86', linewidth=3)\n\n# Set the extent to match the Detroit metro area\nbounds_3857 = transform_bounds(\"EPSG:4326\", \"EPSG:3857\", \n                               x_min, y_min, x_max, y_max)\nax.set_xlim(bounds_3857[0], bounds_3857[2])\nax.set_ylim(bounds_3857[1], bounds_3857[3])\n\nplt.title('IDW Interpolated Asthma Prevalence in Detroit Metro Area', fontsize=16)\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nThis code creates a map of the interpolated asthma prevalence, providing a smooth surface that shows the spatial variation in asthma rates across the Detroit metro area. The use of IDW interpolation helps to create a continuous surface from our discrete census tract data, potentially revealing patterns that might be less apparent in the choropleth map.\nBy comparing this interpolated surface with our earlier maps of air pollution and social vulnerability, we can start to explore potential relationships between environmental factors, social conditions, and health outcomes in the Detroit metro area.\nWe can start with a simple correlation analysis and then visualize it with a scatterplot. The simpleist way to perform the analysis is the extract the raw value pairs and calculate the Pearson correlation.\n\nfrom scipy import stats\n\n# Ensure both rasters have the same shape and are aligned\nair_release_aligned = air_release_raster_da.rio.reproject_match(ds_clipped)\n\n# Flatten the arrays and remove NaN values\nair_release_flat = air_release_aligned.values.flatten()\n# Take the log of the release values to account for extreme outliers\nair_release_flat = np.log1p(air_release_flat)\nasthma_flat = ds_clipped.asthma.values.flatten()\nmask = ~np.isnan(air_release_flat) & ~np.isnan(asthma_flat)\n\ncorrelation, p_value = stats.pearsonr(air_release_flat[mask], asthma_flat[mask])\nprint(f\"Correlation coefficient: {correlation}\")\nprint(f\"P-value: {p_value}\")\n\nCorrelation coefficient: 0.32952588325679505\nP-value: 4.714216462025532e-23\n\n\nCreating a scatterplot of the paired values can provide a better look at what’s going on.\n\n# Create the empty map\nplt.figure(figsize=(7, 7))\n# Create the scatter plot of the values\nplt.scatter(air_release_flat[mask], asthma_flat[mask], alpha=0.5)\n# Create Axis Labels\nplt.xlabel('TRI Air Releases')\nplt.ylabel('Asthma Prevalence')\n# Title\nplt.title('TRI Air Releases vs Asthma Prevalence')\n# Let's see it\nplt.show()\n\n\n\n\n\n\n\n\nThis paints a clearer picture. Although there is a modest positive correlation, there are numerous cells with 0 TRI Air Release and a wide variety of Asthma prevelance values, which negates any correlation we might be seeing at higher release levels. This is a simple pixel by pixel comparison of matching values. We can perform a more robust analysis accounting for the spatial strucuture using a global autocorrelation analysis and Moran’s I.\nPearson’s correlation and Moran’s I are both measures of association, but they serve different purposes and account for different aspects of data. Pearson’s correlation measures the linear relationship between two variables without considering their spatial context. It simply looks at how two variables change together, regardless of where the data points are located in space. In contrast, Moran’s I is specifically designed for spatial data and measures spatial autocorrelation – the degree to which a variable is correlated with itself across geographic space. Moran’s I takes into account both the values of observations and their spatial relationships, typically using a spatial weights matrix. While Pearson’s correlation can tell you if two variables are related overall, Moran’s I can reveal whether high or low values of a variable tend to cluster together in space, or if they’re randomly distributed. This makes Moran’s I particularly useful for analyzing geographical patterns and spatial dependencies, which are crucial in fields like environmental science, epidemiology, and urban planning.\nWe can perform this analysis in Python use pysal. We already know our data is spatially aligned from the previous code chunks. We can create a spatial data frame and continue on.\n\nfrom pysal.explore import esda\nfrom pysal.lib import weights\nimport shapely\n\n# Convert rasters to a GeoDataFrame\ndf = gpd.GeoDataFrame(\n    {\n        'air_release': air_release_aligned.values.flatten(),\n        'asthma': ds_clipped.asthma.values.flatten(),\n        'geometry': [\n            shapely.geometry.Point(x, y) \n            for x, y in zip(\n                np.repeat(air_release_aligned.x.values, len(air_release_aligned.y)),\n                np.tile(air_release_aligned.y.values, len(air_release_aligned.x))\n            )\n        ]\n    }\n)\n\n\n\n\n\n\n\n\n\nStatistics Review\n\n\n\nA p-value, or probability value, is a statistical concept used to determine the significance of results in hypothesis testing. It represents the probability of obtaining results at least as extreme as the observed results, assuming that the null hypothesis is true. In simpler terms, it measures the strength of evidence against the null hypothesis. P-values range from 0 to 1, with lower values indicating stronger evidence against the null hypothesis. Typically, a p-value below a predetermined threshold (often 0.05) is considered statistically significant, suggesting that the observed results are unlikely to have occurred by chance alone. However, it’s important to note that while p-values can indicate the strength of evidence against the null hypothesis, they do not prove or disprove hypotheses, nor do they measure the size or importance of an effect. They should be interpreted in conjunction with other factors such as effect size, sample size, and practical significance.\n\n\nCheck for missing values and create the spatial weights matrix that determines how wide of a net we want to cast as we search for a local dependence structure (you could change these values and see how it impacts the results). You can read more about settings for spatial autocorrelation and Moran’s I analysis here.\n\n# Remove any rows with NaN values\ndf = df.dropna()\n\n# Create a spatial weights matrix\nw = weights.distance.KNN.from_dataframe(df, k=8)  # Using 8 nearest neighbors\nw.transform = 'r'  # Row-standardize the weights\n\nNow we’ll cycle through the Moran function for air release, current asthma among adults, and the 2 combined (bivariate). First air releases.\n\n# Create a Moran scatter plot for air release\nfrom splot.esda import moran_scatterplot\n\n# Calculate Moran's I for air release\nmoran_air = esda.Moran(df['air_release'], w)\n\nprint(\"Moran's I for Air Release:\")\nprint(f\"I: {moran_air.I}\")\nprint(f\"p-value: {moran_air.p_sim}\")\n\nfig, ax = plt.subplots(figsize=(7, 7))\nmoran_scatterplot(moran_air, ax=ax)\n# Get the current limits\nxlim = ax.get_xlim()\nylim = ax.get_ylim()\n# Find the min and max of both axes\nvmin = min(xlim[0], ylim[0])\nvmax = max(xlim[1], ylim[1])\n# Set both axes to the same limits\nax.set_xlim(vmin, vmax)\nax.set_ylim(vmin, vmax)\n# Ensure the aspect ratio is 1:1\nax.set_aspect('equal', adjustable='box')\nax.set_title(\"Moran Scatter Plot: Air Release\")\nplt.show()\n\nMoran's I for Air Release:\nI: 0.11614142149447003\np-value: 0.001\n\n\n\n\n\n\n\n\n\nWhen evaluating Moran’s I for single variables we are assessing how clustered like values are; i.e. do high or low values of air release tend to appear next to each other. On a scale of -1 to 1 a 0.12 suggests a slight positive correlation. High values of air release tend to cluster in similar spots. That said the correlation is lower and we can the same feature as before in that there are a large amount of 0 values that are mixed in all throughout the data. You could attempt to address this issue by using a larger resolution when creating the raster layer depicting air release sums (we used 5000m), or by including different sources of air pollution.\n\n# Calculate Moran's I for asthma prevalence\nmoran_asthma = esda.Moran(df['asthma'], w)\n\nprint(\"\\nMoran's I for Asthma Prevalence:\")\nprint(f\"I: {moran_asthma.I}\")\nprint(f\"p-value: {moran_asthma.p_sim}\")\n\n# Create a Moran scatter plot for asthma prevalence\nfig, ax = plt.subplots(figsize=(7, 7))\nmoran_scatterplot(moran_asthma, ax=ax)\n# Get the current limits\nxlim = ax.get_xlim()\nylim = ax.get_ylim()\n# Find the min and max of both axes\nvmin = min(xlim[0], ylim[0])\nvmax = max(xlim[1], ylim[1])\n# Set both axes to the same limits\nax.set_xlim(vmin, vmax)\nax.set_ylim(vmin, vmax)\n# Ensure the aspect ratio is 1:1\nax.set_aspect('equal', adjustable='box')\nax.set_title(\"Moran Scatter Plot: Asthma Prevalence\")\nplt.show()\n\n\nMoran's I for Asthma Prevalence:\nI: 0.5179466646931635\np-value: 0.001\n\n\n\n\n\n\n\n\n\nAsthma prevelance has a much stronger correlation structure. High asthma levels are clustered together spatially and have a value of 0.52. Also note that the scatterplot shows a nice fit without any odd artifacts or outliers.\n\n# Calculate bivariate Moran's I\nmoran_bv = esda.Moran_BV(df['air_release'], df['asthma'], w)\n\nprint(\"\\nBivariate Moran's I (Air Release vs Asthma):\")\nprint(f\"I: {moran_bv.I}\")\nprint(f\"p-value: {moran_bv.p_sim}\")\n\n# Create a bivariate Moran scatter plot\nfig, ax = plt.subplots(figsize=(7, 7))\n# make the plot\nmoran_scatterplot(moran_bv, ax=ax)\n# Get the current limits\nxlim = ax.get_xlim()\nylim = ax.get_ylim()\n# Find the min and max of both axes\nvmin = min(xlim[0], ylim[0])\nvmax = max(xlim[1], ylim[1])\n# Set both axes to the same limits\nax.set_xlim(vmin, vmax)\nax.set_ylim(vmin, vmax)\n# Ensure the aspect ratio is 1:1\nax.set_aspect('equal', adjustable='box')\n# Set the title\nax.set_title(\"Bivariate Moran Scatter Plot: Air Release vs Asthma\")\nplt.show()\n\n\nBivariate Moran's I (Air Release vs Asthma):\nI: 0.10554510298823498\np-value: 0.001\n\n\n\n\n\n\n\n\n\nSimilar to the pearson analysis, when we analyze their combined spatial dependence the relatipnship is not as strong; largely in part to the high levels of 0 air release values. That said the relationship is positive and it is statistically significant (p-value 0.001).\nThis could be due to several factors that went unaccounted for in our simple analysis.\n\nOur choice of size/resolution when creating our summed air release raster.\nThe impacts of TRI air releases could be much more widespread than the 5km resolution we specified.\nWe only analyze TRI regulated facilities and their emissions.\nWe did not account for traffic density or other sources of particulate matter emissions.\nWe did not control for socioeconomic status, prevantative healthcare access, and a whole host of other confounding variables.\nThere is no underlying relationship. Unlikely based on large amounts of peer reviewed literature, but a possibility none the less.\n\n\n\n\n\n\n\nKnowledge Check\n\n\n\nWhat type of data does the CDC PLACES dataset provide?\n\nReal-time air quality measurements\nEstimates of various health indicators at local levels\nHospital admission rates for air pollution-related illnesses\nLocations of healthcare facilities in each county"
  },
  {
    "objectID": "m202-svi-tri-icis-places.html#lesson-3",
    "href": "m202-svi-tri-icis-places.html#lesson-3",
    "title": "Exploring SVI, TRI, and Health Outcomes",
    "section": "Lesson 3",
    "text": "Lesson 3\nIn this lesson, we explored ….\nLesson 3\n\n\n\nClear the Air Coalition"
  },
  {
    "objectID": "m202-svi-tri-icis-places.html#conclusion",
    "href": "m202-svi-tri-icis-places.html#conclusion",
    "title": "Exploring SVI, TRI, and Health Outcomes",
    "section": "Conclusion",
    "text": "Conclusion\nThis lesson provided a comprehensive exploration of various environmental and public health datasets, focusing on the Detroit metropolitan area. By analyzing data from ICIS-AIR, the Toxic Release Inventory (TRI), the Social Vulnerability Index (SVI), and CDC PLACES, we gained insights into the complex relationships between industrial air pollution, social vulnerability, and health outcomes. The integration of these datasets, combined with geospatial analysis techniques, allowed us to identify areas where environmental hazards and social vulnerabilities intersect, highlighting potential environmental justice concerns. This approach demonstrates the power of combining diverse datasets and utilizing geospatial tools to inform policy decisions and target interventions in areas of greatest need."
  },
  {
    "objectID": "m202-svi-tri-icis-places.html#key-learning-points",
    "href": "m202-svi-tri-icis-places.html#key-learning-points",
    "title": "Exploring SVI, TRI, and Health Outcomes",
    "section": "Key Learning Points",
    "text": "Key Learning Points\nCongratulations! In this lesson you:\n\nAccessed and processed data from multiple EPA and CDC APIs, including ICIS-AIR, TRI, and PLACES datasets\nCreated and manipulated geospatial objects using libraries such as GeoPandas and rasterio\nVisualized point data on maps using Matplotlib and Contextily\nPerformed data cleaning and preprocessing, including handling missing coordinates and outliers\nCreated choropleth maps to visualize health outcomes data at the census tract level\nUtilized Inverse Distance Weighting (IDW) interpolation to create continuous surfaces from point data\nIntegrated multiple datasets to create a composite index (Air Release Vulnerability Index)\nAnalyzed spatial patterns of air pollution, social vulnerability, and health outcomes\nApplied raster math and resampling techniques to align and compare different spatial datasets\nInterpreted results in the context of environmental justice and public health concerns\nPerform a Pearson and Moran’s I correlation analysis"
  },
  {
    "objectID": "m204-grdiv1-pm25.html",
    "href": "m204-grdiv1-pm25.html",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "",
    "text": "In this lesson, you will use NASA socioeconomic and environmental Earthdata available at NASA SEDAC to compare relationships between levels of socioeconomic deprivation agaisnts air quality data of particulate matter (PM) in different international administrative areas.\nThis lesson walks through the process of calculating and visualizing zonal statistics for a set of countries using raster data, focusing on GRDI country quintiles and PM2.5 concentration levels within these quintile areas. It begins by subsetting data by country and iterating over each country to extract relevant zonal statistics like mean, median, and various percentiles for each quintile. These statistics are stored in a GeoDataFrame, which is later used to create a choropleth map that visualizes specific GRDI metrics across countries. The lesson includes a detailed analysis of PM2.5 concentrations within different GRDI quartiles for selected countries. This involves clipping the raster data to each country’s geometry, filtering the data based on the GRDI quartiles, and calculating the mean PM2.5 levels for each quartile. The results are then visualized using customized plots to highlight the relationship between air quality and GRDI metrics across the selected countries."
  },
  {
    "objectID": "m204-grdiv1-pm25.html#learning-objectives",
    "href": "m204-grdiv1-pm25.html#learning-objectives",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter completing this lesson, you should be able to:\n\nGain a general understanding of what is particulate matter (PM) in the air and how it impacts human health.\nLearn about global socioeconomic dimensions of deprivation and how they are spatially represented.\nFind statistical thresholds in socioeconomic data.\nPerform zonal statistics to summarize spatial data\nResample spatial data to harmoniza and compare socioeconomic data against environmental data.\nDisplay data on a maps to get a general understanding of the spatial distribution of data.\nSummarize spatial data into table plots to compare how air quality differs in different socioeconomic conditions of international administrative areas."
  },
  {
    "objectID": "m204-grdiv1-pm25.html#introduction",
    "href": "m204-grdiv1-pm25.html#introduction",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "m204-grdiv1-pm25.html#data-collection-and-integration",
    "href": "m204-grdiv1-pm25.html#data-collection-and-integration",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Data Collection and Integration",
    "text": "Data Collection and Integration\nThe Global (GL) Annual PM2.5 Grids from MODIS, MISR and SeaWiFS Aerosol Optical Depth (AOD), v4.03 (1998 – 2019) can can be downloaded from the Socioeconomic Data and Applications Center ([SEDAC](https://sedac.ciesin.columbia.edu/)) (Center For International Earth Science Information Network-CIESIN-Columbia University 2022a).\nThe Global Gridded Relative Deprivation Index (GRDI), v1 (2010 – 2020) dataset can be downloaded from SEDAC as well (Center For International Earth Science Information Network-CIESIN-Columbia University 2022b).\nGather comprehensive datasets from reliable sources such as the US EPA’s EJSCREEN tool and other public health databases like John Hopkins and County Health Rankings. Integrate relevant environmental data (e.g., air pollutant concentrations, pollution source proximity) with health outcomes data (e.g., COVID-19 prevalence, NSCLC incidence). Ensure data compatibility and quality through data cleaning and validation procedures.\n\nPreparing Environment and Variables\nImporting python packages required:\n\nimport xarray as xr\nimport rioxarray\nimport rasterstats\nfrom rasterio.enums import Resampling\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport geopandas as gpd\nimport pygadm\n\nimport plotly.graph_objects as go \n\nLoad the GRDIv1 and PM2.5 data from local sources:\n\n# Load rasters\ngrdi_path = r\"Z:\\Sedac\\GRDI\\data\\povmap-grdi-v1-geotiff\\final data\\povmap-grdi-v1.tif\"\npm25_path = r\"F:\\TOPSSCHOOL\\git\\TOPSTSCHOOL-air-quality\\data\\sdei-global-annual-gwr-pm2-5-modis-misr-seawifs-aod-v4-gl-03-2019-geotiff\\sdei-global-annual-gwr-pm2-5-modis-misr-seawifs-aod-v4-gl-03-2019.tif\"\n\nUsing the package rasterio to load the data into memory. This allows us to read the data and use it for processing.\n\n# Open the input and reference rasters\ngrdi_raster = rioxarray.open_rasterio(grdi_path, mask_and_scale=True)\npm25_raster = rioxarray.open_rasterio(pm25_path, mask_and_scale=True)\n\n\n\nMatching Data Points using Bilinear Resample\nThe GRDI raster and PM2.5 rasters are incompatible in resolution. One method of harmonizing data is by using the Resampling bethod with a bilinear method. In this case, we reduce, or coarsen, the resolution of the GRDI raster to match the PM2.5 raster.\n\n# Resample the input raster to match the reference raster\ngrdi_raster = grdi_raster.rio.reproject_match(pm25_raster,resampling=Resampling.bilinear)"
  },
  {
    "objectID": "m204-grdiv1-pm25.html#previewing-spatial-data-in-a-plot",
    "href": "m204-grdiv1-pm25.html#previewing-spatial-data-in-a-plot",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Previewing Spatial Data in a Plot",
    "text": "Previewing Spatial Data in a Plot\n\n# Plotting the rasters\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 20))\n\n# Plot the original GRDI raster in the first subplot\nim1 = ax1.imshow(grdi_raster.values[0], cmap='viridis', interpolation='nearest')\nax1.set_title('Original GRDI Raster')\nfig.colorbar(im1, ax=ax1, orientation='horizontal', label='GRDI Values')\n\n# Plot the PM2.5 raster in the second subplot\nim2 = ax2.imshow(pm25_raster.values[0], cmap='hot', interpolation='nearest')\nax2.set_title('PM2.5 Raster')\nfig.colorbar(im2, ax=ax2, orientation='horizontal', label='PM2.5 Values')\n\n\n# Show the plots\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "m204-grdiv1-pm25.html#working-with-administrative-data",
    "href": "m204-grdiv1-pm25.html#working-with-administrative-data",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Working with administrative Data",
    "text": "Working with administrative Data\npygadm is a package that has international administrative units from levels 0 to 2. We can search the available countries by listing the Names.\n\ncountry_table = gpd.GeoDataFrame(pygadm.Names())\nlen(country_table)\n\n263\n\n\nSome available areas with a unique GID_0 code share Names; therefore we drop the rows that contain digits.\n\ncountry_table = country_table[~country_table['GID_0'].str.contains('\\d', na=False)]\nlen(country_table)\n\n254\n\n\n\nSubset Data From a Table\nDoing Zonal statistics for more than 200 countries may take a while, therefore, we can subset the data randomly with the .sample() method.\n\ncountry_sample = country_table.sample(n=15)\ncountry_sample\n\n\n\n\n\n  \n    \n      \n      NAME_0\n      GID_0\n    \n  \n  \n    \n      127\n      Kiribati\n      KIR\n    \n    \n      80\n      Micronesia\n      FSM\n    \n    \n      177\n      Oman\n      OMN\n    \n    \n      262\n      Zimbabwe\n      ZWE\n    \n    \n      63\n      Djibouti\n      DJI\n    \n    \n      9\n      Armenia\n      ARM\n    \n    \n      249\n      Vanuatu\n      VUT\n    \n    \n      37\n      Botswana\n      BWA\n    \n    \n      196\n      Russia\n      RUS\n    \n    \n      164\n      Mayotte\n      MYT\n    \n    \n      261\n      Northern Cyprus\n      ZNC\n    \n    \n      14\n      Australia\n      AUS\n    \n    \n      202\n      South Georgia and the South Sand\n      SGS\n    \n    \n      221\n      Syria\n      SYR\n    \n    \n      129\n      South Korea\n      KOR"
  },
  {
    "objectID": "m204-grdiv1-pm25.html#zonal-statistics-for-each-administrative-area",
    "href": "m204-grdiv1-pm25.html#zonal-statistics-for-each-administrative-area",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Zonal Statistics for Each Administrative Area",
    "text": "Zonal Statistics for Each Administrative Area\nrasterstats has a funcion zonal_stats() which allows you to use vectors to summarize raster data. We summarize GRDIv1 data to calculate the following statistics: count, minimum, mean, max, median, standard deviation, range, and percentiles 20, 40, 60, and 80.\n\nstats_results = gpd.GeoDataFrame()\n\nfor index, row in country_sample.iloc[:].iterrows():\n    country = row['NAME_0']\n    country_GID = row['GID_0']\n    try:\n        country_poly =  pygadm.Items(admin=country_GID, content_level=0)\n    except:\n        print(country, \" skipped.\")\n        continue\n\n    # Create a mask for the polygons\n    grdi_country_zs= rasterstats.zonal_stats(country_poly, grdi_raster.values[0], affine=grdi_raster.rio.transform(), stats=\"count min mean max median std median range percentile_20 percentile_40 percentile_60 percentile_80\")\n    # # pm25_country_zs= rasterstats.zonal_stats(country_poly, pm25_arr, affine=pm25_transform, stats=\"count min mean max median std median range percentile_20 percentile_40 percentile_60 percentile_80\", nodata=pm25_raster.nodata)\n    # # Extract statistics into a dictionary\n    country_stats = {\n        'Country_Name': country,\n        'Country_GID' : country_GID,\n        'GRDI_Count': grdi_country_zs[0]['count'],\n        'GRDI_Min': grdi_country_zs[0]['min'],\n        'GRDI_Mean': grdi_country_zs[0]['mean'],\n        'GRDI_Max': grdi_country_zs[0]['max'],\n        'GRDI_Median': grdi_country_zs[0]['median'],\n        'GRDI_Std': grdi_country_zs[0]['std'],\n        'GRDI_Range': grdi_country_zs[0]['range'],\n        'GRDI_P20': grdi_country_zs[0]['percentile_20'],\n        'GRDI_P40': grdi_country_zs[0]['percentile_40'],\n        'GRDI_P60': grdi_country_zs[0]['percentile_60'],\n        'GRDI_P80': grdi_country_zs[0]['percentile_80'],\n        #     # 'PM25_Count': pm25_country_zs[0]['count'],\n        #     # 'PM25_Min': pm25_country_zs[0]['min'],\n        # 'PM25_Mean': pm25_country_zs[0]['mean'],\n        #     # 'PM25_Max': pm25_country_zs[0]['max'],\n        #     # 'PM25_Median': pm25_country_zs[0]['median'],\n        #     # 'PM25_Std': pm25_country_zs[0]['std'],\n        #     # 'PM25_Range': pm25_country_zs[0]['range'],\n        #     # 'PM25_P20': pm25_country_zs[0]['percentile_20'],\n        #     # 'PM25_P40': pm25_country_zs[0]['percentile_40'],\n        #     # 'PM25_P60': pm25_country_zs[0]['percentile_60'],\n        #     # 'PM25_P80': pm25_country_zs[0]['percentile_80'],\n        'geometry' : country_poly['geometry'].iloc[0]\n    }\n    country_stats_gdf = gpd.GeoDataFrame([country_stats], geometry='geometry')\n    # stats_results.append(country_stats_gdf)\n    stats_results = pd.concat([stats_results, country_stats_gdf], ignore_index=True)\n\nLet’s use the .head() method from Pandas to check the top of our table\n\nstats_results.head()\n\n\n\n\n\n  \n    \n      \n      Country_Name\n      Country_GID\n      GRDI_Count\n      GRDI_Min\n      GRDI_Mean\n      GRDI_Max\n      GRDI_Median\n      GRDI_Std\n      GRDI_Range\n      GRDI_P20\n      GRDI_P40\n      GRDI_P60\n      GRDI_P80\n      geometry\n    \n  \n  \n    \n      0\n      Kiribati\n      KIR\n      116\n      55.782413\n      80.730006\n      84.099190\n      83.011345\n      5.609290\n      28.316776\n      79.892601\n      82.550774\n      83.338074\n      83.656990\n      MULTIPOLYGON (((-143.0905 -17.8498, -143.0858 ...\n    \n    \n      1\n      Micronesia\n      FSM\n      345\n      32.953396\n      74.996014\n      85.425018\n      77.590477\n      7.864845\n      52.471622\n      71.955696\n      76.526154\n      78.361168\n      79.964798\n      MULTIPOLYGON (((154.7811 1.0278, 154.7797 1.02...\n    \n    \n      2\n      Oman\n      OMN\n      38957\n      5.814715\n      58.435711\n      75.041962\n      64.611206\n      14.829892\n      69.227246\n      48.413792\n      61.939667\n      66.912010\n      68.876038\n      MULTIPOLYGON (((54.806 16.9438, 54.8076 16.942...\n    \n    \n      3\n      Zimbabwe\n      ZWE\n      180198\n      24.202816\n      89.134846\n      97.393387\n      89.752472\n      3.847163\n      73.190571\n      87.505157\n      88.919373\n      90.362289\n      91.690750\n      MULTIPOLYGON (((32.7043 -18.9602, 32.7081 -18....\n    \n    \n      4\n      Djibouti\n      DJI\n      781\n      26.355202\n      77.480739\n      94.670731\n      85.478348\n      15.927292\n      68.315529\n      70.784187\n      84.738541\n      85.735367\n      85.902008\n      MULTIPOLYGON (((43.0834 11.182, 43.0013 11.051..."
  },
  {
    "objectID": "m204-grdiv1-pm25.html#defining-a-funtion",
    "href": "m204-grdiv1-pm25.html#defining-a-funtion",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Defining a Funtion",
    "text": "Defining a Funtion\nWe can create a custom function that can allow us to use the zonal statistics process multiple times. A custom function can be created using the def FUNCTION_NAME(PARAMETER1, PARAMETER2): fuction to define what the fucntion will do.\n\ndef calculate_country_stats(country_sample, grdi_raster, pm25_raster=None):\n    \"\"\"\n    Calculate statistics for each country in the sample.\n\n    Parameters:\n    - country_sample: A pandas DataFrame containing country information with 'NAME_0' and 'GID_0' columns, in this case the country_table.\n    - grdi_raster: A raster object with which to perform the zonal statistics.\n    - pm25_raster: (Optional) A raster object for PM2.5 data. If provided, statistics will also be calculated for this raster.\n\n    Returns:\n    - stats_results: A GeoDataFrame containing the statistics for each country.\n    \"\"\"\n    stats_results = gpd.GeoDataFrame()\n\n    for index, row in country_sample.iloc[:].iterrows():\n        country = row['NAME_0']\n        country_GID = row['GID_0']\n        try:\n            country_poly = pygadm.Items(admin=country_GID, content_level=0)\n        except Exception as e:\n            print(country, \"skipped due to error:\", e)\n            continue\n\n        # Create a mask for the polygons and perform zonal statistics on GRDI raster\n        grdi_country_zs = rasterstats.zonal_stats(\n            country_poly, grdi_raster.values[0], \n            affine=grdi_raster.rio.transform(), \n            stats=\"count min mean max median std range percentile_20 percentile_40 percentile_60 percentile_80\"\n        )\n\n        # Uncomment and update the following lines if you want to include PM2.5 statistics\n        # if pm25_raster is not None:\n        #     pm25_country_zs = rasterstats.zonal_stats(\n        #         country_poly, pm25_raster.values[0], \n        #         affine=pm25_raster.rio.transform(), \n        #         stats=\"count min mean max median std range percentile_20 percentile_40 percentile_60 percentile_80\", \n        #         nodata=pm25_raster.nodata\n        #     )\n\n        # Extract statistics into a dictionary\n        country_stats = {\n            'Country_Name': country,\n            'Country_GID' : country_GID,\n            'GRDI_Count': grdi_country_zs[0]['count'],\n            'GRDI_Min': grdi_country_zs[0]['min'],\n            'GRDI_Mean': grdi_country_zs[0]['mean'],\n            'GRDI_Max': grdi_country_zs[0]['max'],\n            'GRDI_Median': grdi_country_zs[0]['median'],\n            'GRDI_Std': grdi_country_zs[0]['std'],\n            'GRDI_Range': grdi_country_zs[0]['range'],\n            'GRDI_P20': grdi_country_zs[0]['percentile_20'],\n            'GRDI_P40': grdi_country_zs[0]['percentile_40'],\n            'GRDI_P60': grdi_country_zs[0]['percentile_60'],\n            'GRDI_P80': grdi_country_zs[0]['percentile_80'],\n            'geometry' : country_poly['geometry'].iloc[0]\n        }\n\n        # If PM2.5 statistics are calculated, add them to the dictionary\n        # if pm25_raster is not None:\n        #     country_stats.update({\n        #         'PM25_Count': pm25_country_zs[0]['count'],\n        #         'PM25_Min': pm25_country_zs[0]['min'],\n        #         'PM25_Mean': pm25_country_zs[0]['mean'],\n        #         'PM25_Max': pm25_country_zs[0]['max'],\n        #         'PM25_Median': pm25_country_zs[0]['median'],\n        #         'PM25_Std': pm25_country_zs[0]['std'],\n        #         'PM25_Range': pm25_country_zs[0]['range'],\n        #         'PM25_P20': pm25_country_zs[0]['percentile_20'],\n        #         'PM25_P40': pm25_country_zs[0]['percentile_40'],\n        #         'PM25_P60': pm25_country_zs[0]['percentile_60'],\n        #         'PM25_P80': pm25_country_zs[0]['percentile_80'],\n        #     })\n\n        country_stats_gdf = gpd.GeoDataFrame([country_stats], geometry='geometry')\n        stats_results = pd.concat([stats_results, country_stats_gdf], ignore_index=True)\n\n    return stats_results\n\nFrom the table above, we can choose an attribute, or column, to display it in a map plot. In this case, I’m choosing the GRDI Max\n\ncolumn_chosen = 'GRDI_Max' #GRDI_Max, GRDI_Min, GRDI_Median\n# Plotting\nfig, ax = plt.subplots(1, 1, figsize=(15, 10))\nstats_results.plot(column=column_chosen, ax=ax, legend=True,\n    legend_kwds={'label': f\"{column_chosen} per country.\",\n                      'orientation': \"horizontal\"})\nax.set_title('Choropleth Map Showing GRDI Mean per country')\nax.set_axis_off()  # Turn off the axis numbers and ticks\nplt.show()\n\n\n\n\n\nSelecting Data by Column\nStart my creating a list of countries that you are interested in to Subset data from the DataFrame that match the values in the NAME_0 column. The .isin() mehthod checks each element in the DataFrame’s column for the item present in the list and returns matching rows.\n\n# selected_countries = [\"Algeria\", \"Somalia\", \"Colombia\", \"Timor Leste\", \"Finland\", \"Nicaragua\", \"United Kingdom\", \"Mali\"]\n# selected_countries = [\"Anguilla\", \"Armenia\", \"Angola\", \"Argentina\", \"Albania\", \"United Arab Emirates\", \"American Samoa\", \"Australia\" ]\nselected_countries = [\"Algeria\", \"Somalia\", \"Colombia\", \"Timor Leste\", \"Finland\", \"Nicaragua\", \"United Kingdom\", \"Mali\", \"Armenia\", \"Argentina\",  \"Albania\", \"United Arab Emirates\", \"Indonesia\", \"Qatar\"]\n\n#use the list above to subset the country_table DataFrame by the column NAME_0 \nselected_countries = country_table[country_table['NAME_0'].isin(selected_countries)]\n\n\n\nUsing a Defined Custom Function\nRecalling the defined fucntion calculate_country_stats, we can use our selected_countries list, and the GRDI and PM2.5 rasters, to create a new table of zonal statistics.\n\nstats_results = calculate_country_stats(selected_countries, grdi_raster)\n\nShow the head of the table again:\n\nstats_results.head()\n\n\n\n\n\n  \n    \n      \n      Country_Name\n      Country_GID\n      GRDI_Count\n      GRDI_Min\n      GRDI_Mean\n      GRDI_Max\n      GRDI_Median\n      GRDI_Std\n      GRDI_Range\n      GRDI_P20\n      GRDI_P40\n      GRDI_P60\n      GRDI_P80\n      geometry\n    \n  \n  \n    \n      0\n      Albania\n      ALB\n      19076\n      8.272310\n      61.513866\n      75.395561\n      66.220139\n      11.644754\n      67.123251\n      55.861691\n      64.445587\n      67.104332\n      68.589424\n      MULTIPOLYGON (((20.0541 39.6917, 20.0389 39.69...\n    \n    \n      1\n      United Arab Emirates\n      ARE\n      18229\n      5.732072\n      42.347647\n      67.470955\n      45.034630\n      17.949307\n      61.738883\n      24.688160\n      38.623692\n      50.710217\n      61.909931\n      MULTIPOLYGON (((54.1541 22.7548, 53.3313 22.85...\n    \n    \n      2\n      Argentina\n      ARG\n      474297\n      7.572341\n      66.341158\n      81.701645\n      68.789696\n      10.416561\n      74.129304\n      66.774643\n      68.278297\n      69.335510\n      71.098465\n      MULTIPOLYGON (((-66.5458 -55.061, -66.5486 -55...\n    \n    \n      3\n      Armenia\n      ARM\n      9108\n      6.944193\n      59.871617\n      73.707901\n      64.272858\n      12.315193\n      66.763708\n      52.692970\n      61.288189\n      66.743027\n      69.004845\n      MULTIPOLYGON (((45.8319 39.8311, 45.8448 39.82...\n    \n    \n      4\n      Colombia\n      COL\n      223557\n      11.956444\n      71.523674\n      84.922409\n      73.350586\n      8.762370\n      72.965965\n      69.966934\n      72.190056\n      74.405403\n      76.502792\n      MULTIPOLYGON (((-77.491 4.1451, -77.4985 4.140...\n    \n  \n\n\n\n\nPlot the map again choosing a column to plot:\n\ncolumn_chosen = 'GRDI_Max' #GRDI_Max, GRDI_Min, GRDI_Median\nstats_results.plot(column=column_chosen, legend=True)\nplt.show()"
  },
  {
    "objectID": "m204-grdiv1-pm25.html#creating-a-table-with-results",
    "href": "m204-grdiv1-pm25.html#creating-a-table-with-results",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Creating a Table with Results",
    "text": "Creating a Table with Results\nWe can create a list of tuples that we can use to refer to the GRDI statistical values, and the name, color, and symbol we want to assign. In this case, we are using the GRDI zonal statistics of each country we selected that include the Mean, Minimum, Maximum, and interquartiles.\n\n# List of GRDI values and their corresponding properties\n#column, value name, color, symbol\ngrdi_data = [\n    ('GRDI_Mean', 'Mean', 'orange', 'diamond'),\n    ('GRDI_Min', 'Min', 'gray', '152'),\n    ('GRDI_Max', 'Max', 'gray', '151'),\n    ('GRDI_P20', 'Q20', 'blue', '142'),\n    ('GRDI_P40', 'Q40', 'purple', '142'),\n    ('GRDI_P60', 'Q60', 'green', '142'),\n    ('GRDI_P80', 'Q80', 'red', '142')\n]\n\nWe can create a figure to display the data based on the names colors and symbols we selected.\n\n# Create a figure\nfig = go.Figure()\n\n# Add traces to the figure based on the data\nfor col, name, color, symbol in grdi_data:\n    fig.add_trace(go.Scatter(\n        x=stats_results[col],\n        y=stats_results['Country_Name'],\n        mode='markers',\n        name=name,\n        marker=dict(color=color, size=10, symbol=symbol)\n    ))\n\n# Customize layout\nfig.update_layout(\n    title='GRDI Statistics by Country',\n    xaxis_title='GRDI Values',\n    yaxis_title='Country Name',\n    yaxis=dict(tickmode='linear'),\n    legend_title='Statistics',\n    yaxis_type='category',\n    xaxis=dict(tickvals=[0, 20, 40, 60, 80, 100])\n)\n\n# Show plot\nfig.show()"
  },
  {
    "objectID": "m204-grdiv1-pm25.html#summarizing-pm2.5-values-by-socioeconomic-deprivation",
    "href": "m204-grdiv1-pm25.html#summarizing-pm2.5-values-by-socioeconomic-deprivation",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Summarizing PM2.5 Values by Socioeconomic Deprivation",
    "text": "Summarizing PM2.5 Values by Socioeconomic Deprivation\nConsidering the GRDI quartile values as a level of socieoeconomic deprivation within each country, we can use the stats_results GeoDataFrame, the GRDI raster, and the PM2.5 raster to calculate the Mean PM.25 value within each of those areas in each country. This can describe how the air quality for different socioeconomic strata compare within the country, as well as against other countries.\nThe results will be added to the stats_results with the corresponting columns.\n\n# iterate through the stats_results table rows\nfor index, row in stats_results.iloc[:].iterrows():\n    #isolate each country's respective row\n    row_df = gpd.GeoDataFrame([row], geometry='geometry').reset_index(drop=True)\n    print(row_df.loc[0,'Country_GID'])\n    try:\n        #use rioxarray to clip the GRDI and PM2.5 rasters by the geometry of the respective country.\n        grdi_country = grdi_raster.rio.clip(row_df.geometry, grdi_raster.rio.crs)\n        pm25_country = pm25_raster.rio.clip(row_df.geometry, grdi_raster.rio.crs)\n    except:\n        print('Error in clip')\n        continue\n\n    #Applying squeeze() to this array removes the singleton dimension, reducing it to a 2D array with dimensions (rows, columns)\n    grdi_country= grdi_country.squeeze()\n    pm25_country= pm25_country.squeeze()\n\n\n    # Subset the GRDI raster where values fall between each GRDI quintiles\n    grdi_countryQ1 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_Min']) & (grdi_country <= row_df.loc[0, 'GRDI_P20']))\n    grdi_countryQ2 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_P20']) & (grdi_country <= row_df.loc[0, 'GRDI_P40']))\n    grdi_countryQ3 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_P40']) & (grdi_country <= row_df.loc[0, 'GRDI_P60']))\n    grdi_countryQ4 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_P60']) & (grdi_country <= row_df.loc[0, 'GRDI_P80']))\n    grdi_countryQ5 = grdi_country.where((grdi_country >= row_df.loc[0, 'GRDI_P80']) & (grdi_country <= row_df.loc[0, 'GRDI_Max']))\n\n\n    # Mask the PM2.5 raster using the above GRDI quartile rasters, keeping only the cells that intersect\n    pm25_countryQ1 = pm25_country.where(grdi_countryQ1.notnull())\n    pm25_countryQ2 = pm25_country.where(grdi_countryQ2.notnull())\n    pm25_countryQ3 = pm25_country.where(grdi_countryQ3.notnull())\n    pm25_countryQ4 = pm25_country.where(grdi_countryQ4.notnull())\n    pm25_countryQ5 = pm25_country.where(grdi_countryQ5.notnull())\n\n    #Find the mean value of of the intersected PM2.5 rasters in each quartile\n    pm25_countryQ1v = pm25_countryQ1.mean().item()\n    pm25_countryQ2v = pm25_countryQ2.mean().item()\n    pm25_countryQ3v = pm25_countryQ3.mean().item()\n    pm25_countryQ4v = pm25_countryQ4.mean().item()\n    pm25_countryQ5v = pm25_countryQ5.mean().item()\n\n    #add the resuts to the stats_results table in the respective column\n    stats_results.at[index, 'PM25_Q1'] = pm25_countryQ1v\n    stats_results.at[index, 'PM25_Q2'] = pm25_countryQ2v\n    stats_results.at[index, 'PM25_Q3'] = pm25_countryQ3v\n    stats_results.at[index, 'PM25_Q4'] = pm25_countryQ4v\n    stats_results.at[index, 'PM25_Q5'] = pm25_countryQ5v\n\nALB\n\n\nARE\n\n\nARG\n\n\nARM\n\n\nCOL\n\n\nDZA\n\n\nFIN\n\n\nGBR\n\n\nIDN\n\n\nMLI\n\n\nNIC\n\n\nQAT\n\n\nSOM\n\n\n\nstats_results.head()\n\n\n\n\n\n  \n    \n      \n      Country_Name\n      Country_GID\n      GRDI_Count\n      GRDI_Min\n      GRDI_Mean\n      GRDI_Max\n      GRDI_Median\n      GRDI_Std\n      GRDI_Range\n      GRDI_P20\n      GRDI_P40\n      GRDI_P60\n      GRDI_P80\n      geometry\n      PM25_Q1\n      PM25_Q2\n      PM25_Q3\n      PM25_Q4\n      PM25_Q5\n    \n  \n  \n    \n      0\n      Albania\n      ALB\n      19076\n      8.272310\n      61.513866\n      75.395561\n      66.220139\n      11.644754\n      67.123251\n      55.861691\n      64.445587\n      67.104332\n      68.589424\n      MULTIPOLYGON (((20.0541 39.6917, 20.0389 39.69...\n      15.438293\n      15.031855\n      14.699892\n      14.612475\n      15.709009\n    \n    \n      1\n      United Arab Emirates\n      ARE\n      18229\n      5.732072\n      42.347647\n      67.470955\n      45.034630\n      17.949307\n      61.738883\n      24.688160\n      38.623692\n      50.710217\n      61.909931\n      MULTIPOLYGON (((54.1541 22.7548, 53.3313 22.85...\n      47.710175\n      47.893559\n      47.822292\n      48.220722\n      49.729328\n    \n    \n      2\n      Argentina\n      ARG\n      474297\n      7.572341\n      66.341158\n      81.701645\n      68.789696\n      10.416561\n      74.129304\n      66.774643\n      68.278297\n      69.335510\n      71.098465\n      MULTIPOLYGON (((-66.5458 -55.061, -66.5486 -55...\n      7.519970\n      5.924110\n      6.083218\n      7.562082\n      8.672854\n    \n    \n      3\n      Armenia\n      ARM\n      9108\n      6.944193\n      59.871617\n      73.707901\n      64.272858\n      12.315193\n      66.763708\n      52.692970\n      61.288189\n      66.743027\n      69.004845\n      MULTIPOLYGON (((45.8319 39.8311, 45.8448 39.82...\n      19.292490\n      16.728804\n      16.334721\n      16.337336\n      15.342737\n    \n    \n      4\n      Colombia\n      COL\n      223557\n      11.956444\n      71.523674\n      84.922409\n      73.350586\n      8.762370\n      72.965965\n      69.966934\n      72.190056\n      74.405403\n      76.502792\n      MULTIPOLYGON (((-77.491 4.1451, -77.4985 4.140...\n      27.425064\n      29.047859\n      24.132767\n      22.309097\n      20.367249"
  },
  {
    "objectID": "m204-grdiv1-pm25.html#plot-results-of-mean-pm2.5-in-socieceonomic-deprivation-quartiles-per-country",
    "href": "m204-grdiv1-pm25.html#plot-results-of-mean-pm2.5-in-socieceonomic-deprivation-quartiles-per-country",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Plot Results of Mean PM2.5 in Socieceonomic Deprivation Quartiles per country",
    "text": "Plot Results of Mean PM2.5 in Socieceonomic Deprivation Quartiles per country\nSimilarly, we create a list of tuples of how we want to display the data, and create a figure based on the tuples. This plot would show each country in the y axis and the Log of Mean PM2.5 values in each country’s GRDI quarties.\n\n# List of GRDI values and their corresponding properties\n#column, value name, color, symbol\nplot_data =[\n    ('PM25_Q1', 'Q1', '#440154', '6'),  # Light Blue\n    ('PM25_Q2', 'Q2', '#31688E', '5'),  # Light Green\n    ('PM25_Q3', 'Q3', '#35B779', '7'),  # Yellow\n    ('PM25_Q4', 'Q4', '#FDE725', '8'),  # Orange\n    ('PM25_Q5', 'Q5', '#FF0000', '1')   # Red\n]\n\n# Create a figure\nfig = go.Figure()\n\n# Add traces to the figure.\nfor col, name, color, symbol in plot_data:\n    xlog  = np.log(stats_results[col])\n    fig.add_trace(go.Scatter(\n        x=xlog,\n        y=stats_results['Country_Name'],\n        mode='markers+text',  # Add 'text' to mode\n        text=[f'<b>{name}</b>' for _ in stats_results[col]],  # Repeat name for each point\n        name=name,\n        textfont=dict(color=color, size=12),\n        textposition='top center',  # Position the text above the symbol\n        marker_color=color,\n        marker_line_color=\"midnightblue\",\n        marker_symbol=symbol,\n        marker_size=14,\n        marker_line_width=2,\n        marker_opacity=0.6\n        ))\nfig.update_traces(textposition='top center')\n\n    # Customize layout\nfig.update_layout(\n    title='Mean PM2.5 in each GRDI Quartile by Country',\n    xaxis_title='Log of PM2.5 Mean Values',\n    yaxis_title='Country Name',\n    yaxis=dict(tickmode='linear'),\n    legend_title='Statistics',\n    yaxis_type='category',\n    xaxis=dict(rangemode=\"tozero\"),\n    \n    #xaxis=dict(tickvals=[0, 20, 40, 60, 80, 100])\n    )\n\n# Show plot\nfig.show()\n\n\n                                                \n\n\nUse the plotly controls to take a closer look at the results.\nWith this shapely plot, We can examine differences between countires and PM2.5 values. The plot displays the coutnries on the Y axis and log values of the average PM2.5 value on the X axis. Each country displays PM2.5 values averaged within the quartile areas based on GRDI values of each country. A higher quartile (Q) implies a higher degree of deprivation, 1 being the lowest and 5 the highest.\nCongratulations! …. Now you should be able to:\n\nTest test…"
  },
  {
    "objectID": "m204-grdiv1-pm25.html#module-2-air-quality-home",
    "href": "m204-grdiv1-pm25.html#module-2-air-quality-home",
    "title": "Particulate Matter Across Socioeconomic Strata of Countries",
    "section": "Module 2: Air Quality Home",
    "text": "Module 2: Air Quality Home\nIn this lesson, we explored ….\nModule 2: Air Quality"
  },
  {
    "objectID": "m203-ejscreen.html",
    "href": "m203-ejscreen.html",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "",
    "text": "In this lesson, you will use…."
  },
  {
    "objectID": "m203-ejscreen.html#learning-objectives",
    "href": "m203-ejscreen.html#learning-objectives",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nAfter completing this lesson, you should be able to:\n\nManipulating and processing raster data; mainly loading and cropping.\nExploring SVI/raster by mapping and processing different sub datasets (overall/racial/socioeconomic).\nConnecting to API’s for pollution and public health data.\nGeolocating tabular data with latitude and longitude.\nJoining tabular data to spatial data (probably polygons).\nConnecting to OpenStreetMap API for basemaps.\nCreating regional basemaps.\nLayering spatial data on basemaps.\n\nSemi-transparent SVI, TRI points, PLACES boundaries.\n\nCreating maps with graduated point symbols for point source pollution releases.\nCreating choropleths with census tract polygons for health outcomes data.\nZonal statistics with census tracts for:\n\nMean SVI values\nHealth outcomes summaries weighted by SVI.\n\n(Maybe) Interpolate pollution load raster surface from point data.\nSpatial correlation analysis between SVI, point pollution, and health outcomes. ."
  },
  {
    "objectID": "m203-ejscreen.html#introduction",
    "href": "m203-ejscreen.html#introduction",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "Introduction",
    "text": "Introduction\nAir Quality and Environmental Justice:\nIn many urban areas, air quality issues disproportionately affect low-income communities and communities of color. This disparity is a key focus of environmental justice efforts. In cities like Detroit and Chicago, industrial facilities, highways, and other pollution sources are often concentrated in disadvantaged neighborhoods.\nNIMBY and Environmental Justice:\nThe NIMBY phenomenon can sometimes conflict with environmental justice goals. While wealthier communities may successfully oppose new polluting facilities in their areas, this can lead to these facilities being placed in less affluent neighborhoods with less political clout, exacerbating environmental injustices.\nCommunity-Driven Science:\nIn response to these challenges, community-driven science initiatives have emerged. These efforts involve local residents in collecting data on air quality and other environmental factors, often using low-cost sensors and mobile monitoring techniques. This approach helps fill gaps in official monitoring networks and empowers communities to advocate for themselves.\nDetroit and Chicago Examples:\nDetroit: The city has a history of industrial pollution and is working to address air quality issues in areas like Southwest Detroit, where residents face higher exposure to pollutants from nearby industries and heavy truck traffic.\nChicago: The city has seen community efforts to address air pollution in areas like the Southeast Side, where residents have fought against polluting industries and advocated for stricter regulations.\nThese topics are interconnected, as community-driven science often arises in response to environmental justice concerns, while NIMBY attitudes can influence the distribution of pollution sources across urban areas.\nEPA (Environmental Protection Agency):\nThe EPA is the primary federal agency responsible for environmental protection in the United States. It sets and enforces air quality standards, including the National Ambient Air Quality Standards (NAAQS) for six criteria pollutants. The EPA also maintains the AirNow system, which provides real-time air quality data to the public. CDC (Centers for Disease Control and Prevention): While primarily focused on public health, the CDC plays a crucial role in understanding the health impacts of air pollution. It conducts research on the relationships between air quality and various health outcomes, and provides guidance on protecting public health from environmental hazards. Importance of Open Data: Open data is crucial for community-driven solutions in several ways:\nTransparency: Open data allows communities to verify official reports and hold authorities accountable. Accessibility: When air quality data is freely available, communities can use it to inform local decision-making and advocacy efforts. Innovation: Open data enables researchers, activists, and tech developers to create new tools and analyses that can benefit communities. Collaboration: Open data facilitates collaboration between communities, scientists, and policymakers, leading to more effective solutions.\nExamples of Open Data in Action:\n\nThe EPA’s Air Quality System (AQS) database is publicly accessible, allowing researchers and community groups to analyze historical air quality trends.\nIn Chicago, the Array of Things project has installed sensors throughout the city, providing open data on various environmental factors including air quality.\nDetroit’s Community Air Monitoring Project uses low-cost sensors to collect and share air quality data in areas underserved by official monitoring stations.\nCommunity-Driven Solutions: With access to open data, communities can:\nIdentify local air quality hotspots that may be missed by sparse official monitoring networks.\nCorrelate air quality data with health outcomes to strengthen advocacy efforts.\nDevelop targeted interventions, such as promoting indoor air filtration on high-pollution days.\nCreate custom alerts and information systems tailored to local needs.\n\nChallenges and Opportunities: While open data provides many benefits, challenges remain:\n\nEnsuring data quality and consistency, especially when integrating data from various sources.\nAddressing the “digital divide” to ensure all community members can access and use the data. Balancing the need for detailed local data with privacy concerns.\nBuilding capacity within communities to effectively use and interpret complex environmental data.\n\nThe EPA, CDC, and other agencies are increasingly recognizing the value of community-driven science and open data. This has led to initiatives like the EPA’s Community-Focused Exposure and Risk Screening Tool (C-FERST) and the CDC’s Environmental Public Health Tracking Network, which aim to make environmental health data more accessible to communities.\nEGLE and Environmental Justice in Detroit\n\nCertainly. Detroit, Michigan has indeed seen significant environmental justice efforts, particularly in collaboration with EGLE (Michigan Department of Environment, Great Lakes, and Energy). Here are some examples:\nDetroit Environmental Agenda: This community-led initiative works closely with EGLE to address environmental concerns in Detroit. It focuses on issues like air quality, water quality, and waste management.\n48217 Community Air Monitoring Project: Named after the zip code of a heavily industrialized area in Southwest Detroit, this project involves community members working with EGLE to monitor air quality using low-cost sensors.\nDetroit Climate Action Plan: Developed in partnership with EGLE, this plan addresses climate change impacts on the city, with a focus on vulnerable communities.\nDelray Neighborhood Initiatives: EGLE has been involved in efforts to address air quality concerns in the Delray neighborhood, which is impacted by industrial emissions and heavy truck traffic.\nGreen Door Initiative: This Detroit-based organization collaborates with EGLE on various environmental justice projects, including lead abatement and air quality improvement efforts.\nDetroit River Sediment Cleanup: EGLE has been involved in efforts to clean up contaminated sediments in the Detroit River, which disproportionately affects nearby low-income communities.\nAsthma Prevention Programs: EGLE supports community-based asthma prevention programs in Detroit, recognizing the link between air quality and asthma rates in disadvantaged neighborhoods.\n\nThese examples demonstrate the ongoing collaboration between community groups, local government, and EGLE to address environmental justice concerns in Detroit. However, as with many environmental justice efforts, challenges remain and work is ongoing.\n\n\n\n\n\n\nData Science Review\n\n\n\nThis lesson uses the pandas, geopandas, matplotlib, numpy, requests, contextily, pygris, rasterio, and xarray modules. If you’d like to learn more about the functions used in this lesson, you can refer to the documentation on their respective websites.\nThe pandas module is essential for data manipulation and analysis, while geopandas extends its functionality to handle geospatial data. matplotlib is used for creating static, animated, and interactive visualizations. numpy provides support for large, multi-dimensional arrays and matrices, along with a collection of mathematical functions to operate on these arrays.\nThe requests module allows you to send HTTP requests and interact with APIs easily. contextily adds basemaps to your plots, enhancing the visual context of your geospatial data. pygris simplifies the process of working with US Census Bureau TIGER/Line shapefiles.\nrasterio and xarray are used for working with geospatial raster data. rasterio reads and writes geospatial raster datasets, while xarray introduces labels in the form of dimensions, coordinates, and attributes on top of raw NumPy-like arrays, making it easier to work with labeled multi-dimensional arrays.\nMake sure these modules are installed before you begin working with the code in this document. You can install them using pip:"
  },
  {
    "objectID": "m203-ejscreen.html#load-the-data",
    "href": "m203-ejscreen.html#load-the-data",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "Load the Data",
    "text": "Load the Data"
  },
  {
    "objectID": "m203-ejscreen.html#svi-and-detroit-metro",
    "href": "m203-ejscreen.html#svi-and-detroit-metro",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "SVI and Detroit Metro",
    "text": "SVI and Detroit Metro\nSVI has a primary overall SVI score, but also provides sublayers. These include minority, socioeconomic, housing, and household data.\n\nimport xarray as xr\nimport rasterio\nimport rasterio.mask\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport pygris\nimport numpy as np\n\n# Fetch Detroit metro area counties using pygris\nmetro_counties = pygris.counties(state=\"MI\", year=2022)\ndetroit_metro = metro_counties[metro_counties['NAME'].isin([\n    'Wayne', 'Oakland', 'Macomb', 'Livingston', 'St. Clair', 'Lapeer'\n])]\n\n# Dissolve the counties into a single polygon\ndetroit_metro = detroit_metro.dissolve(by='STATEFP')\n\n# Convert to GeoDataFrame\ndetroit_metro = gpd.GeoDataFrame(detroit_metro, geometry='geometry', crs='EPSG:4269')\n\n# Specify the TIF files\ntif_files = [\n    \"data/svi/svi_2020_tract_overall_wgs84.tif\",\n    \"data/svi/svi_2020_tract_minority_wgs84.tif\",\n    \"data/svi/svi_2020_tract_socioeconomic_wgs84.tif\",\n    \"data/svi/svi_2020_tract_housing_wgs84.tif\",\n    \"data/svi/svi_2020_tract_household_wgs84.tif\"\n]\n\n# Create an empty list to store the individual DataArrays\ndata_arrays = []\n\n# Read each TIF file, clip it to Detroit metro's extent, and append it to the list\nfor file in tif_files:\n    with rasterio.open(file) as src:\n        # Reproject Detroit metro boundary to match the raster CRS\n        metro_reprojected = detroit_metro.to_crs(src.crs)\n        \n        # Clip the raster to Detroit metro's geometry\n        out_image, out_transform = rasterio.mask.mask(src, metro_reprojected.geometry, crop=True)\n        out_meta = src.meta.copy()\n        \n        # Update the metadata\n        out_meta.update({\"driver\": \"GTiff\",\n                         \"height\": out_image.shape[1],\n                         \"width\": out_image.shape[2],\n                         \"transform\": out_transform})\n        \n        # Create coordinates\n        height = out_meta['height']\n        width = out_meta['width']\n        cols, rows = np.meshgrid(np.arange(width), np.arange(height))\n        xs, ys = rasterio.transform.xy(out_transform, rows, cols)\n        \n        # Convert lists to numpy arrays\n        xs = np.array(xs)\n        ys = np.array(ys)\n        \n        # Reshape coordinates to match dimensions of the raster\n        xs = xs.reshape(height, width)\n        ys = ys.reshape(height, width)\n        \n        # Create a DataArray from the clipped data\n        da = xr.DataArray(out_image[0],  # Use the first band\n                          coords={'y': ('y', ys[:, 0]),\n                                  'x': ('x', xs[0, :])},\n                          dims=['y', 'x'])\n        da.attrs['crs'] = str(src.crs)  # Convert CRS to string\n        da.attrs['transform'] = out_transform\n        data_arrays.append(da)\n\n# Combine all DataArrays into a single DataSet\nds = xr.concat(data_arrays, dim='layer')\n\n# Rename the layers using the appropriate dimension\nds = ds.assign_coords(layer=('layer', ['Overall', 'Minority', 'Socioeconomic', 'Housing', 'Household']))\n\n# Define the colorbar limits\nvmin, vmax = 0, 1\n\n# Create a multipanel plot\nfig, axes = plt.subplots(3, 2, figsize=(15, 20))\naxes = axes.flatten()\n\n# Plot each layer\nfor i, layer in enumerate(ds.layer.values):\n    # Plot with custom color limits\n    im = ds.sel(layer=layer).plot(ax=axes[i], add_colorbar=False, vmin=vmin, vmax=vmax, cmap='viridis')\n    axes[i].set_title(layer)\n    \n    # Plot Detroit metro boundary\n    metro_reprojected.boundary.plot(ax=axes[i], color='red', linewidth=1)\n\n# Remove the extra subplot\nfig.delaxes(axes[5])\n\n# Add a single colorbar\ncbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])\ncbar = fig.colorbar(im, cax=cbar_ax, label='SVI Score')\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "m203-ejscreen.html#tri-api-column-definitions",
    "href": "m203-ejscreen.html#tri-api-column-definitions",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "TRI API Column Definitions",
    "text": "TRI API Column Definitions\n\n\n\n\n\n\n\nColumn Name\nDescription\n\n\n\n\nFACILITY_NAME\nThe name of the facility reporting to TRI\n\n\nTRI_FACILITY_ID\nA unique identifier for the facility in the TRI database\n\n\nSTREET_ADDRESS\nThe street address of the facility\n\n\nCITY_NAME\nThe city where the facility is located\n\n\nCOUNTY_NAME\nThe county where the facility is located\n\n\nSTATE_ABBR\nThe two-letter abbreviation for the state where the facility is located\n\n\nZIP_CODE\nThe ZIP code of the facility’s location\n\n\nPREF_LATITUDE\nThe preferred latitude coordinate of the facility\n\n\nPREF_LONGITUDE\nThe preferred longitude coordinate of the facility\n\n\nPARENT_CO_NAME\nThe name of the parent company, if applicable\n\n\nINDUSTRY_SECTOR_CODE\nA code representing the industry sector of the facility\n\n\nINDUSTRY_SECTOR\nA description of the industry\n\n\n\nNote: The availability and exact names of these columns may vary depending on the specific TRI API endpoint and query parameters used. Always refer to the official EPA TRI documentation for the most up-to-date and comprehensive information.\n\nImportant Considerations\n\nNot all columns may be present in every API response.\nColumn names may have slight variations (e.g., with or without underscores).\nThe EPA occasionally updates their API and data structure.\nSome columns related to chemical releases and waste management may have additional variations or breakdowns.\nNumeric values (like release amounts) are typically reported in pounds, but always verify the units.\nFor coordinates (PREF_LATITUDE and PREF_LONGITUDE), be aware that these are the preferred coordinates, which may have been adjusted for accuracy or privacy reasons."
  },
  {
    "objectID": "m203-ejscreen.html#envirofacts-tri-facilities-w-api",
    "href": "m203-ejscreen.html#envirofacts-tri-facilities-w-api",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "ENVIROFACTS TRI Facilities w/ API",
    "text": "ENVIROFACTS TRI Facilities w/ API\n\nimport xarray as xr\nimport rasterio\nimport rasterio.mask\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport pygris\nimport numpy as np\nfrom shapely.geometry import box\nimport pandas as pd\nimport requests\nimport contextily as ctx\n\n# Fetch Detroit metro area counties using pygris\nmetro_counties = pygris.counties(state=\"MI\", year=2022)\ndetroit_metro = metro_counties[metro_counties['NAME'].isin([\n    'Wayne', 'Oakland', 'Macomb', 'Livingston', 'St. Clair', 'Lapeer'\n])]\n\n# Dissolve the counties into a single polygon\ndetroit_metro = detroit_metro.dissolve(by='STATEFP')\n\n# Get the bounding box\nbbox = detroit_metro.total_bounds\n\n# Print the bounding box coordinates\nprint(\"Bounding Box:\")\nprint(f\"Minimum X (Longitude): {bbox[0]}\")\nprint(f\"Minimum Y (Latitude): {bbox[1]}\")\nprint(f\"Maximum X (Longitude): {bbox[2]}\")\nprint(f\"Maximum Y (Latitude): {bbox[3]}\")\n\n# Create the bounding box as a polygon\nbbox_polygon = gpd.GeoDataFrame(\n    geometry=[box(*bbox)],\n    crs=detroit_metro.crs\n)\n\n# Fetch TRI facility data from EPA API for each county\ncounties = ['Wayne', 'Oakland', 'Macomb', 'Livingston', 'St. Clair', 'Lapeer']\ntri_data = []\n\nfor county in counties:\n    api_url = f\"https://data.epa.gov/efservice/tri_facility/state_abbr/MI/county_name/{county}/JSON\"\n    response = requests.get(api_url)\n    if response.status_code == 200:\n        county_data = response.json()\n        tri_data.extend(county_data)\n    else:\n        print(f\"Failed to fetch data for {county} County. Status code: {response.status_code}\")\n\n# Convert TRI data to a DataFrame\ntri_df = pd.DataFrame(tri_data)\n\nprint(f\"Number of facilities fetched: {len(tri_df)}\")\n\n# Create a copy of the dataframe to avoid SettingWithCopyWarning\ntri_df_clean = tri_df.copy()\n\n# Remove facilities with empty latitude or longitude values\ntri_df_clean = tri_df_clean.dropna(subset=['pref_latitude', 'pref_longitude'])\n\nprint(f\"Number of facilities after removing empty coordinates: {len(tri_df_clean)}\")\n\n# Convert latitude and longitude to numeric type\ntri_df_clean['pref_latitude'] = pd.to_numeric(tri_df_clean['pref_latitude'], errors='coerce')\ntri_df_clean['pref_longitude'] = pd.to_numeric(tri_df_clean['pref_longitude'], errors='coerce')\n\n# Function to correct longitude\ndef correct_longitude(lon):\n    if lon > 0:\n        return -lon\n    return lon\n\n# Apply longitude correction\ntri_df_clean['pref_longitude'] = tri_df_clean['pref_longitude'].apply(correct_longitude)\n\n# Calculate IQR for longitude\nQ1 = tri_df_clean['pref_longitude'].quantile(0.25)\nQ3 = tri_df_clean['pref_longitude'].quantile(0.75)\nIQR = Q3 - Q1\n\n# Define bounds for outliers\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n\n# Remove outliers\ntri_df_clean = tri_df_clean[(tri_df_clean['pref_longitude'] >= lower_bound) & \n                            (tri_df_clean['pref_longitude'] <= upper_bound)]\n\nprint(f\"Number of facilities after removing longitude outliers: {len(tri_df_clean)}\")\n\n# Create a GeoDataFrame from the cleaned TRI data\ndetroit_tri = gpd.GeoDataFrame(\n    tri_df_clean, \n    geometry=gpd.points_from_xy(tri_df_clean.pref_longitude, tri_df_clean.pref_latitude),\n    crs=\"EPSG:4326\"\n)\n\n# Reproject data to Web Mercator for contextily\ndetroit_metro = detroit_metro.to_crs(epsg=3857)\nbbox_polygon = bbox_polygon.to_crs(epsg=3857)\ndetroit_tri = detroit_tri.to_crs(epsg=3857)\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(15, 15))\n\n# Plot the metro area and bounding box\ndetroit_metro.plot(ax=ax, color='lightblue', edgecolor='black', alpha=0.5)\nbbox_polygon.boundary.plot(ax=ax, color='red', linewidth=2)\n\n# Plot TRI facilities\ndetroit_tri.plot(ax=ax, color='red', markersize=50, alpha=0.7)\n\n# Add the basemap\nctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent of the map to the bounding box\nax.set_xlim(bbox_polygon.total_bounds[0], bbox_polygon.total_bounds[2])\nax.set_ylim(bbox_polygon.total_bounds[1], bbox_polygon.total_bounds[3])\n\n# Remove axes\nax.set_axis_off()\n\nplt.title(\"Detroit Metro Area TRI Facilities\", fontsize=16)\nplt.tight_layout()\nplt.show()\n\nprint(f\"Final number of TRI facilities in the Detroit metro area: {len(detroit_tri)}\")"
  },
  {
    "objectID": "m203-ejscreen.html#regulated-facilities-w-icis-air",
    "href": "m203-ejscreen.html#regulated-facilities-w-icis-air",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "Regulated Facilities w/ ICIS-AIR",
    "text": "Regulated Facilities w/ ICIS-AIR\n\nimport pandas as pd\nimport requests\nimport time\n\n# Base URL for ECHO ICIS-AIR API\nbase_url = \"https://echodata.epa.gov/echo/air_rest_services\"\n\n# Parameters for the initial API call\nparams = {\n    \"output\": \"JSON\",\n    \"p_st\": \"MI\"\n}\n\ndef get_facilities():\n    response = requests.get(f\"{base_url}.get_facilities\", params=params)\n    if response.status_code == 200:\n        data = response.json()\n        if 'Results' in data:\n            qid = data['Results']['QueryID']\n            print(f\"Query ID: {qid}\")\n            print(f\"Total Facilities: {data['Results']['QueryRows']}\")\n            return qid\n    print(\"Failed to get facilities and QID\")\n    return None\n\ndef get_facility_data(qid):\n    all_facilities = []\n    page = 1\n    while True:\n        params = {\"qid\": qid, \"pageno\": page, \"output\": \"JSON\"}\n        response = requests.get(f\"{base_url}.get_qid\", params=params)\n        if response.status_code == 200:\n            data = response.json()\n            if 'Results' in data and 'Facilities' in data['Results']:\n                facilities = data['Results']['Facilities']\n                if not facilities:  # No more facilities to retrieve\n                    break\n                all_facilities.extend(facilities)\n                print(f\"Retrieved page {page}\")\n                page += 1\n            else:\n                break\n        else:\n            print(f\"Failed to retrieve page {page}\")\n            break\n    return all_facilities\n\n# Step 1: Get the Query ID\nqid = get_facilities()\n\nif qid:\n    # Step 2: Use get_qid to retrieve all facility data\n    print(\"Retrieving facility data...\")\n    facilities = get_facility_data(qid)\n    \n    # Convert to DataFrame\n    df_icis_air = pd.DataFrame(facilities)\n    \n    print(f\"\\nSuccessfully retrieved {len(df_icis_air)} ICIS-AIR facilities for Michigan\")\n    print(\"\\nColumns in the dataset:\")\n    print(df_icis_air.columns)\n    \n    # Display the first few rows\n    print(\"\\nFirst few rows of the data:\")\n    print(df_icis_air.head())\n    \n    # Save to CSV\nelse:\n    print(\"Failed to retrieve facility data\")\n\n    import pandas as pd\n\n# List of Detroit metro counties\nmetro_counties = ['Wayne', 'Oakland', 'Macomb', 'Livingston', 'St. Clair', 'Lapeer']\n\n# Subset the dataframe to include only the Detroit metro counties\ndf_detroit_metro = df_icis_air[df_icis_air['AIRCounty'].isin(metro_counties)]\n\n# Print information about the subset\nprint(f\"Total ICIS-AIR facilities in Michigan: {len(df_icis_air)}\")\nprint(f\"ICIS-AIR facilities in Detroit metro area: {len(df_detroit_metro)}\")\n\n# Display the count of facilities in each metro county\nprint(\"\\nFacilities per county:\")\nprint(df_detroit_metro['AIRCounty'].value_counts())\n\n# Display the first few rows of the subset\nprint(\"\\nFirst few rows of the Detroit metro ICIS-AIR facilities:\")\nprint(df_detroit_metro.head())\n\n# Additional information: unique values in AIRCounty\nprint(\"\\nUnique values in AIRCounty column:\")\nprint(df_icis_air['AIRCounty'].unique())\n\nCreate geopandas and plot.\n\n# Count records with missing coordinate values\nmissing_coords = df_detroit_metro[(df_detroit_metro['FacLat'].isnull()) | (df_detroit_metro['FacLong'].isnull())]\nprint(f\"Number of ICIS-AIR records with missing coordinates: {len(missing_coords)}\")\n\n# Remove records with missing coordinates\ndf_detroit_metro = df_detroit_metro.dropna(subset=['FacLat', 'FacLong'])\n\n# Create a GeoDataFrame for ICIS-AIR facilities\ngdf_icis_air = gpd.GeoDataFrame(\n    df_detroit_metro, \n    geometry=gpd.points_from_xy(df_detroit_metro.FacLong, df_detroit_metro.FacLat),\n    crs=\"EPSG:4326\"\n)\n\n# Reproject ICIS-AIR data to Web Mercator\ngdf_icis_air = gdf_icis_air.to_crs(epsg=3857)\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(15, 15))\n\n# Plot the metro area and bounding box (reusing objects from earlier)\ndetroit_metro.plot(ax=ax, facecolor='none', edgecolor='blue', linewidth=2)\nbbox_polygon.boundary.plot(ax=ax, color='red', linewidth=2)\n\n# Plot ICIS-AIR facilities\ngdf_icis_air.plot(ax=ax, color='cyan', markersize=50, alpha=0.7, label='ICIS-AIR Facilities')\n\n# Plot TRI facilities (reusing the detroit_tri object from earlier)\ndetroit_tri.plot(ax=ax, color='purple', markersize=50, alpha=0.7, label='TRI Facilities')\n\n# Add the basemap\nctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent of the map to the bounding box\nax.set_xlim(bbox_polygon.total_bounds[0], bbox_polygon.total_bounds[2])\nax.set_ylim(bbox_polygon.total_bounds[1], bbox_polygon.total_bounds[3])\n\n# Remove axes\nax.set_axis_off()\n\n# Add legend\nax.legend()\n\nplt.title(\"Detroit Metro Area TRI and ICIS-AIR Facilities\", fontsize=16)\nplt.tight_layout()\nplt.show()\n\nprint(f\"Number of TRI facilities plotted: {len(detroit_tri)}\")\nprint(f\"Number of ICIS-AIR facilities plotted: {len(gdf_icis_air)}\")"
  },
  {
    "objectID": "m203-ejscreen.html#custom-tri-form-a-search",
    "href": "m203-ejscreen.html#custom-tri-form-a-search",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "Custom TRI Form A Search",
    "text": "Custom TRI Form A Search\n\n# URL of the CSV file\nurl = \"https://dmap-epa-enviro-prod-export.s3.amazonaws.com/338211710.CSV\"\n\n# Read the CSV file directly with pandas\ndf_tri_custom = pd.read_csv(url)\nprint(f\"Successfully read CSV. Number of records: {len(df_tri_custom)}\")\n\n# Display information about the dataset\nprint(\"\\nColumns in the dataset:\")\nprint(df_tri_custom.columns)\n\n# Assuming the latitude and longitude columns are named 'LATITUDE' and 'LONGITUDE'\n# Adjust these names if they're different in your CSV\nlat_col = 'LATITUDE'\nlon_col = 'LONGITUDE'\nrelease_col = 'AIR_TOTAL_RELEASE'  # Adjust this to the actual column name for air releases\n\n# Remove records with missing coordinates or air release data\ndf_tri_clean = df_tri_custom.dropna(subset=[lat_col, lon_col, release_col])\n\nprint(f\"\\nNumber of records after removing missing data: {len(df_tri_clean)}\")\n\n# Create a GeoDataFrame\ngdf_tri_custom = gpd.GeoDataFrame(\n    df_tri_clean, \n    geometry=gpd.points_from_xy(df_tri_clean[lon_col], df_tri_clean[lat_col]),\n    crs=\"EPSG:4326\"\n)\n\n# Reproject to Web Mercator\ngdf_tri_custom = gdf_tri_custom.to_crs(epsg=3857)\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(15, 15))\n\n# Plot the metro area and bounding box (reusing objects from earlier)\ndetroit_metro.plot(ax=ax, facecolor='none', edgecolor='blue', linewidth=2)\nbbox_polygon.boundary.plot(ax=ax, color='orangered', linewidth=2)\n\n# Plot TRI facilities with graduated symbols based on air releases\nscatter = ax.scatter(gdf_tri_custom.geometry.x, gdf_tri_custom.geometry.y, \n                     # s=gdf_tri_custom[release_col]/100,  # Adjust the scaling factor as needed\n                     c='orangered',  # Static fill color\n                     edgecolor='yellow',  # Outline color\n                     linewidth=1,  # Adjust the outline width as needed\n                     alpha=0.7)\n\n# Add the basemap\nctx.add_basemap(ax, source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent of the map to the bounding box\nax.set_xlim(bbox_polygon.total_bounds[0], bbox_polygon.total_bounds[2])\nax.set_ylim(bbox_polygon.total_bounds[1], bbox_polygon.total_bounds[3])\n\n# Remove axes\nax.set_axis_off()\n\n# Add a legend for symbol sizes\nlegend_sizes = [1000, 10000, 100000]  # Example sizes, adjust based on your data\nlegend_elements = [plt.scatter([], [], s=size/100, c='orangered', edgecolor='yellow', \n                               linewidth=1, alpha=1, label=f'{size:,}') \n                   for size in legend_sizes]\nax.legend(handles=legend_elements, title='Total Air Releases (lbs)', \n          loc='lower right', title_fontsize=12, fontsize=10)\n\nplt.title(\"Detroit Metro Area TRI Facilities - Total Air Releases (Custom Data)\", fontsize=16)\nplt.tight_layout()\nplt.show()\n\nprint(f\"\\nNumber of TRI facilities plotted: {len(gdf_tri_custom)}\")\nprint(f\"Total air releases: {gdf_tri_custom[release_col].sum():,.2f} lbs\")\nprint(f\"Average air release per facility: {gdf_tri_custom[release_col].mean():,.2f} lbs\")\n\n\nRasterizing Pollution Sums\n\nimport numpy as np\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport rasterio\nfrom rasterio import features\nfrom rasterio.transform import from_origin\nfrom matplotlib.colors import BoundaryNorm, ListedColormap\nimport xarray as xr\nimport rioxarray  # This imports rioxarray and adds the .rio accessor to xarray objects\n\n# Ensure gdf_tri_custom and detroit_metro are in the correct CRS (should be EPSG:3857 for Web Mercator)\ngdf_tri_custom = gdf_tri_custom.to_crs(epsg=3857)\ndetroit_metro = detroit_metro.to_crs(epsg=3857)\n\n# Get the bounds of the Detroit metro area\nminx, miny, maxx, maxy = detroit_metro.total_bounds\n\n# Define the resolution (100m)\nresolution = 5000\n\n# Calculate the number of cells\nnx = int((maxx - minx) / resolution)\nny = int((maxy - miny) / resolution)\n\n# Create the transform for the raster\ntransform = from_origin(minx, maxy, resolution, resolution)\n\n# Prepare geometries and values for rasterization\nshapes = ((geom, value) for geom, value in zip(gdf_tri_custom.geometry, gdf_tri_custom.AIR_TOTAL_RELEASE))\n\n# Rasterize the point data\nraster = features.rasterize(shapes=shapes, \n                            out_shape=(ny, nx), \n                            transform=transform, \n                            fill=0, \n                            all_touched=True, \n                            merge_alg=rasterio.enums.MergeAlg.add)\n\n# Convert the raster to an xarray DataArray\n# Note: We use ny and nx here to ensure the coordinates match the raster shape\nraster_da = xr.DataArray(raster, \n                         coords={'y': np.linspace(maxy, miny, ny),\n                                 'x': np.linspace(minx, maxx, nx)},\n                         dims=['y', 'x'])\nraster_da.rio.write_crs(detroit_metro.crs, inplace=True)\n\n# Clip the raster with the Detroit metro boundary\nclipped_raster = raster_da.rio.clip(detroit_metro.geometry.values, detroit_metro.crs, drop=False, all_touched=True)\n\n# Define the breaks for the discrete scale\nbreaks = [0, 1, 10, 100, 1000, 10000, 100000, 250000, 500000]\n\n# Create a custom colormap\ncolors = ['#FFFFFF', '#FFFFCC', '#FFEDA0', '#FED976', '#FEB24C', '#FD8D3C', '#FC4E2A', '#E31A1C', '#B10026']\ncmap = ListedColormap(colors)\n\n# Create a normalization based on the breaks\nnorm = BoundaryNorm(breaks, cmap.N)\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(15, 15))\n\n# Plot the clipped raster with the custom colormap and norm\nim = ax.imshow(clipped_raster, extent=[minx, maxx, miny, maxy], origin='upper', \n               cmap=cmap, norm=norm)\n\n# Add colorbar with discrete labels\ncbar = plt.colorbar(im, ax=ax, extend='max', \n                    label='Total Air Releases (pounds)', \n                    ticks=breaks)\ncbar.ax.set_yticklabels([f'{b:,}' for b in breaks])\n\n# Plot the TRI facility points\ngdf_tri_custom.plot(ax=ax, color='blue', markersize=20, alpha=0.7)\n\n# Plot the Detroit metro boundary\ndetroit_metro.boundary.plot(ax=ax, color='black', linewidth=2)\n\n# Set the extent to match the Detroit metro area\nax.set_xlim(minx, maxx)\nax.set_ylim(miny, maxy)\n\n# Add title and labels\nax.set_title('TRI Air Total Release (100m resolution sum) with Facility Locations', fontsize=16)\nax.set_xlabel('X Coordinate')\nax.set_ylabel('Y Coordinate')\n\nplt.tight_layout()\nplt.show()\n\nprint(f\"Number of TRI facilities plotted: {len(gdf_tri_custom)}\")\nprint(f\"Total air releases: {gdf_tri_custom['AIR_TOTAL_RELEASE'].sum():,.2f}\")\nprint(f\"Maximum cell value in raster: {clipped_raster.max().values:,.2f}\")"
  },
  {
    "objectID": "m203-ejscreen.html#air-release-vulnerability-index",
    "href": "m203-ejscreen.html#air-release-vulnerability-index",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "Air Release Vulnerability Index",
    "text": "Air Release Vulnerability Index\n\nimport numpy as np\nimport xarray as xr\nimport rioxarray\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfrom rasterio.enums import Resampling\nfrom scipy import stats\n\n# Select the 'Overall' layer\nsvi_overall = ds.sel(layer='Overall')\n\n# Convert to rioxarray for geospatial operations\nsvi_overall = svi_overall.rio.write_crs(\"EPSG:4326\")\n\n# Reproject SVI to match the CRS of the air release raster\nsvi_reprojected = svi_overall.rio.reproject_match(clipped_raster)\n\n# Clip SVI raster to the Detroit metro boundary\nsvi_clipped = svi_reprojected.rio.clip(detroit_metro.geometry.values, detroit_metro.crs, drop=True, all_touched=True)\n\n# Disaggregate the air release data to match the resolution of the SVI data\nair_release_disaggregated = clipped_raster.rio.reproject_match(\n    svi_clipped,\n    resampling=Resampling.bilinear\n)\n\n# Calculate raster correlation between SVI overall and air release within Detroit metro boundary\nsvi_flat = svi_clipped.values.flatten()\nair_flat = air_release_disaggregated.values.flatten()\n\n# Remove NaN values\nmask = ~np.isnan(svi_flat) & ~np.isnan(air_flat)\nsvi_flat = svi_flat[mask]\nair_flat = air_flat[mask]\n\ncorrelation, p_value = stats.pearsonr(svi_flat, air_flat)\n\nprint(f\"Raster Correlation between SVI Overall and Air Release within Detroit metro: {correlation:.4f}\")\nprint(f\"P-value: {p_value:.4f}\")\n\n# New correlation analysis\n# Ensure gdf_tri_custom is in the same CRS as svi_clipped\ngdf_tri_custom = gdf_tri_custom.to_crs(svi_clipped.rio.crs)\n\n# Extract SVI values at TRI facility locations\nsvi_values = []\nfor point in gdf_tri_custom.geometry:\n    svi_value = svi_clipped.sel(x=point.x, y=point.y, method=\"nearest\").values\n    svi_values.append(svi_value)\n\n# Add SVI values to gdf_tri_custom\ngdf_tri_custom['SVI_OVERALL'] = svi_values\n\n# Perform correlation analysis\ncorrelation_points, p_value_points = stats.pearsonr(gdf_tri_custom['AIR_TOTAL_RELEASE'], gdf_tri_custom['SVI_OVERALL'])\n\nprint(f\"Point-based Correlation between SVI Overall and AIR_TOTAL_RELEASE: {correlation_points:.4f}\")\nprint(f\"P-value: {p_value_points:.4f}\")\n\n# Log1p transform the air release data and scale to 0-1\nair_release_log = np.log1p(air_release_disaggregated)\nair_release_scaled = (air_release_log - air_release_log.min()) / (air_release_log.max() - air_release_log.min())\n\n# Multiply scaled air release data with SVI data\nvulnerability_indicator = air_release_scaled * svi_clipped\n\n# Create the plots\nfig, axs = plt.subplots(3, 1, figsize=(15, 45))\n\n# Plot SVI Overall\nim1 = svi_clipped.plot(ax=axs[0], cmap='viridis', vmin=0, vmax=1, add_colorbar=False)\nplt.colorbar(im1, ax=axs[0], label='SVI Overall')\naxs[0].set_title('Social Vulnerability Index (Overall)', fontsize=16)\ndetroit_metro.boundary.plot(ax=axs[0], color='black', linewidth=2)\n\n# Plot Original Air Release (log-transformed for better visualization)\nim2 = np.log1p(air_release_disaggregated).plot(ax=axs[1], cmap='YlOrRd', add_colorbar=False)\nplt.colorbar(im2, ax=axs[1], label='Log(Air Release + 1)')\naxs[1].set_title('Air Release (Log-transformed)', fontsize=16)\ndetroit_metro.boundary.plot(ax=axs[1], color='black', linewidth=2)\n\n# Plot Air Release Vulnerability Indicator\nim3 = vulnerability_indicator.plot(ax=axs[2], cmap='YlOrRd', vmin=0, vmax=1, add_colorbar=False)\nplt.colorbar(im3, ax=axs[2], label='Air Release Vulnerability Indicator')\naxs[2].set_title('Air Release Vulnerability Indicator\\n(Scaled Air Release * SVI)', fontsize=16)\ndetroit_metro.boundary.plot(ax=axs[2], color='black', linewidth=2)\n\nfor ax in axs:\n    ax.set_xlabel('Longitude')\n    ax.set_ylabel('Latitude')\n    ax.set_xlim(svi_clipped.x.min(), svi_clipped.x.max())\n    ax.set_ylim(svi_clipped.y.min(), svi_clipped.y.max())\n\nplt.tight_layout()\nplt.show()\n\n# Print some statistics\nprint(f\"Minimum vulnerability indicator: {vulnerability_indicator.min().values:.4f}\")\nprint(f\"Maximum vulnerability indicator: {vulnerability_indicator.max().values:.4f}\")\nprint(f\"Mean vulnerability indicator: {vulnerability_indicator.mean().values:.4f}\")\n\n\n# Convert the vulnerability indicator to a pandas DataFrame\nvulnerability_df = vulnerability_indicator.to_dataframe(name='index').reset_index()\n\n# Sort by index value and get the top 10\ntop_10 = vulnerability_df.sort_values('index', ascending=False).head(10)\n\n# Create points from the coordinates\ntop_10['geometry'] = gpd.points_from_xy(top_10.x, top_10.y)\ntop_10_gdf = gpd.GeoDataFrame(top_10, geometry='geometry', crs=vulnerability_indicator.rio.crs)\n\n# Create the final map\nfig, ax = plt.subplots(figsize=(15, 15))\n\n# Plot the Detroit metro boundary\ndetroit_metro.boundary.plot(ax=ax, color='black', linewidth=2)\n\n# Plot the top 10 points\ntop_10_gdf.plot(ax=ax, color='blue', markersize=100, alpha=0.7)\n\n# Add labels to the points\nfor idx, row in top_10_gdf.iterrows():\n    ax.annotate(f\"#{idx+1}\", (row.geometry.x, row.geometry.y), \n                xytext=(3, 3), textcoords=\"offset points\", \n                color='white', fontweight='bold')\n\n# Add a basemap\nctx.add_basemap(ax, crs=vulnerability_indicator.rio.crs.to_string(), source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent to match the Detroit metro area\nax.set_xlim(vulnerability_indicator.x.min(), vulnerability_indicator.x.max())\nax.set_ylim(vulnerability_indicator.y.min(), vulnerability_indicator.y.max())\n\nax.set_title('Top 10 Areas with Highest Air Release Vulnerability Index', fontsize=16)\nax.set_axis_off()\n\nplt.tight_layout()\nplt.show()\n\n# Print the coordinates of the top 10 points\nprint(\"Coordinates of the top 10 points:\")\nfor idx, row in top_10_gdf.iterrows():\n    print(f\"#{idx+1}: ({row.geometry.x}, {row.geometry.y})\")"
  },
  {
    "objectID": "m203-ejscreen.html#places",
    "href": "m203-ejscreen.html#places",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "PLACES",
    "text": "PLACES\nThe CDC PLACES (Population Level Analysis and Community Estimates) dataset is a collaboration between the Centers for Disease Control and Prevention (CDC), the Robert Wood Johnson Foundation, and the CDC Foundation. It provides model-based population-level analysis and community estimates of health indicators for all counties, places (incorporated and census designated places), census tracts, and ZIP Code Tabulation Areas (ZCTAs) across the United States.\n\nKey Points\n\nGeographic Coverage: Entire United States, including all 50 states, the District of Columbia, and Puerto Rico.\nGeographic Granularity: Multiple levels including counties, cities/towns, census tracts, and ZIP codes.\nHealth Indicators: Wide range of chronic disease measures related to health outcomes, prevention, and health risk behaviors.\nData Sources:\n\nBehavioral Risk Factor Surveillance System (BRFSS)\nU.S. Census Bureau’s American Community Survey (ACS)\n\nMethodology: Uses small area estimation methods for small geographic areas.\nHealth Measures Include:\n\nChronic diseases: e.g., asthma, COPD, heart disease, diabetes\nHealth risk behaviors: e.g., smoking, physical inactivity, binge drinking\nPrevention practices: e.g., health insurance coverage, dental visits, cholesterol screening\n\nSocioeconomic Data: Includes some socioeconomic and demographic variables.\nAnnual Updates: Providing recent estimates for local areas.\n\nThis dataset is particularly valuable for: - Public health researchers - Policymakers - Community organizations\nIt provides a standardized way to compare health indicators across different geographic areas and can be used to inform targeted interventions and policy decisions, especially in addressing health disparities at a local level.\n\n\nProcessing\n\nimport geopandas as gpd\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport requests\nimport contextily as ctx\n\n# Define the GeoJSON API endpoint\nurl = \"https://data.cdc.gov/resource/cwsq-ngmh.geojson\"\n\n# Define the Detroit metro area counties\ndetroit_counties = ['Wayne', 'Oakland', 'Macomb', 'Livingston', 'St. Clair', 'Lapeer']\n\n# Create the county filter string\ncounty_filter = \" OR \".join([f\"countyname = '{county}'\" for county in detroit_counties])\n\n# Define the query parameters\nparams = {\n    \"$where\": f\"stateabbr = 'MI' AND ({county_filter})\",\n    \"$limit\": 50000  # Adjust if necessary\n}\n\n# Make the API request\nresponse = requests.get(url, params=params)\n\nif response.status_code == 200:\n    data = response.json()\n    print(f\"Successfully retrieved data\")\nelse:\n    print(f\"Failed to retrieve data. Status code: {response.status_code}\")\n    print(response.text)\n\n# Convert to GeoDataFrame\ngdf = gpd.read_file(response.text)\n\n# Print available health measures\nprint(\"\\nAvailable health measures:\")\nprint(gdf['measure'].unique())\n\n# Print the first few rows to see the structure of the data\nprint(\"\\nFirst few rows of the GeoDataFrame:\")\nprint(gdf.head())\n\n# Print basic information about the GeoDataFrame\nprint(\"\\nGeoDataFrame Info:\")\nprint(gdf.info())\n\n# Create a sample map for one health measure (e.g., Current asthma)\nfig, ax = plt.subplots(figsize=(15, 15))\n\n# Filter for the specific measure and ensure data_value is numeric\ngdf_asthma = gdf[gdf['measure'] == 'Current asthma among adults'].copy()\ngdf_asthma['data_value'] = pd.to_numeric(gdf_asthma['data_value'], errors='coerce')\n\n# Plot the asthma data\ngdf_asthma.plot(column='data_value', \n                ax=ax, \n                legend=True, \n                legend_kwds={'label': 'Asthma Prevalence (%)', 'orientation': 'horizontal'},\n                cmap='YlOrRd',\n                missing_kwds={'color': 'lightgrey'})\n\n# Add county boundaries\n#gdf_asthma.dissolve(by='countyname').boundary.plot(ax=ax, color='black', linewidth=0.5)\n\n# Add basemap\nctx.add_basemap(ax, crs=gdf_asthma.crs.to_string(), source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent to match the Detroit metro area\nax.set_xlim(gdf_asthma.total_bounds[0], gdf_asthma.total_bounds[2])\nax.set_ylim(gdf_asthma.total_bounds[1], gdf_asthma.total_bounds[3])\n\nplt.title('Asthma Prevalence in Detroit Metro Area', fontsize=16)\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n\n# Print some statistics for the asthma data\nprint(\"\\nAsthma Statistics:\")\nprint(f\"Average asthma prevalence: {gdf_asthma['data_value'].mean():.2f}%\")\nprint(f\"Minimum asthma prevalence: {gdf_asthma['data_value'].min():.2f}%\")\nprint(f\"Maximum asthma prevalence: {gdf_asthma['data_value'].max():.2f}%\")\n\n# Print the number of census tracts per county\nprint(\"\\nNumber of census tracts per county:\")\nprint(gdf_asthma['countyname'].value_counts())\n\n\nimport numpy as np\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport contextily as ctx\nfrom scipy.interpolate import griddata\nimport rasterio\nfrom rasterio.transform import from_origin\n\n# Assuming gdf_asthma is already created and contains the asthma data\n\n# Ensure gdf_asthma is in EPSG:4326\ngdf_asthma = gdf_asthma.to_crs(epsg=4326)\n\n# Extract coordinates and values\nX = gdf_asthma.geometry.x.values\nY = gdf_asthma.geometry.y.values\nZ = gdf_asthma['data_value'].values\n\n# Remove any NaN values\nmask = ~np.isnan(Z)\nX, Y, Z = X[mask], Y[mask], Z[mask]\n\n# Create a grid to interpolate over\ngrid_resolution = 0.025  # in degrees\nx_min, y_min, x_max, y_max = gdf_asthma.total_bounds\ngrid_x = np.arange(x_min, x_max, grid_resolution)\ngrid_y = np.arange(y_min, y_max, grid_resolution)\ngrid_xx, grid_yy = np.meshgrid(grid_x, grid_y)\n\n# Perform IDW interpolation\npoints = np.column_stack((X, Y))\ngrid_z = griddata(points, Z, (grid_xx, grid_yy), method='linear')\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(15, 15))\n\n# Plot the interpolated data\nim = ax.imshow(grid_z, extent=[x_min, x_max, y_min, y_max], \n               origin='lower', cmap='YlOrRd', alpha=0.7)\n\n# Add colorbar\ncbar = plt.colorbar(im, ax=ax, label='Asthma Prevalence')\n\n# Add basemap\nctx.add_basemap(ax, crs=gdf_asthma.crs.to_string(), source=ctx.providers.OpenStreetMap.Mapnik)\n\n# Set the extent to match the Detroit metro area\nax.set_xlim(x_min, x_max)\nax.set_ylim(y_min, y_max)\n\nplt.title('IDW Interpolated Asthma Prevalence in Detroit Metro Area', fontsize=16)\nax.axis('off')\n\nplt.tight_layout()\nplt.show()\n\n# Save the interpolated raster\ntransform = from_origin(x_min, y_max, grid_resolution, grid_resolution)\nwith rasterio.open('idw_asthma.tif', 'w', \n                   driver='GTiff', \n                   height=grid_z.shape[0], \n                   width=grid_z.shape[1], \n                   count=1, \n                   dtype=grid_z.dtype, \n                   crs='EPSG:4326',  # Explicitly set the CRS\n                   transform=transform) as dst:\n    dst.write(grid_z, 1)\n\n# Print some statistics about the interpolated data\nprint(f\"Minimum interpolated value: {np.nanmin(grid_z):.2f}\")\nprint(f\"Maximum interpolated value: {np.nanmax(grid_z):.2f}\")\nprint(f\"Mean interpolated value: {np.nanmean(grid_z):.2f}\")\n\n\n\n\n\n\n\nData Review\n\n\n\nThe Toxics Release Inventory (TRI) and the Integrated Compliance Information System for Air (ICIS-AIR) are two important but distinct environmental reporting systems maintained by the U.S. Environmental Protection Agency (EPA). They have several key differences:\n\nRegulatory Basis\n\nTRI: Established under the Emergency Planning and Community Right-to-Know Act (EPCRA) of 1986\nICIS-AIR: Part of the Clean Air Act (CAA) compliance and enforcement program\n\nFocus\n\nTRI: Tracks the management of certain toxic chemicals that may pose a threat to human health and the environment\nICIS-AIR: Focuses specifically on air quality and emissions from facilities regulated under the Clean Air Act\n\nReported Information\n\nTRI: Facilities report on releases, waste management, and pollution prevention activities for specific toxic chemicals\nICIS-AIR: Tracks emissions data, compliance status, and enforcement actions related to air quality regulations\n\nFacility Coverage\n\nTRI: Covers facilities in specific industries that manufacture, process, or use TRI-listed chemicals above certain thresholds\nICIS-AIR: Includes a broader range of facilities that emit air pollutants, regardless of the specific chemicals involved\n\nReporting Thresholds\n\nTRI: Has specific chemical thresholds that trigger reporting requirements\nICIS-AIR: Generally doesn’t have chemical-specific thresholds; requirements are based on overall emissions and facility type\n\nPublic Accessibility\n\nTRI: Designed with a strong focus on public right-to-know, with data easily accessible to the public\nICIS-AIR: While public, it’s primarily designed for regulatory and enforcement purposes\n\nData Frequency\n\nTRI: Annual reporting is required for covered facilities\nICIS-AIR: May involve more frequent reporting, depending on permit requirements and compliance status\n\nScope of Pollutants\n\nTRI: Focuses on a specific list of toxic chemicals and chemical categories\nICIS-AIR: Covers a wider range of air pollutants, including criteria air pollutants and hazardous air pollutants\n\nUse in Environmental Management\n\nTRI: Often used for assessing long-term trends in toxic chemical releases and waste management practices\nICIS-AIR: More commonly used for day-to-day air quality management and enforcement activities\n\nGeographic Coverage\n\nTRI: Nationwide program with consistent reporting across states\nICIS-AIR: While national, implementation can vary more by state or local air quality management district\n\n\n\n\n\n\nDeployment\nCongratulations! …. Now you should be able to:\n\nTest test…"
  },
  {
    "objectID": "m203-ejscreen.html#lesson-3",
    "href": "m203-ejscreen.html#lesson-3",
    "title": "SVI, TRI, and Health Outcomes",
    "section": "Lesson 3",
    "text": "Lesson 3\nIn this lesson, we explored ….\nLesson 3"
  }
]